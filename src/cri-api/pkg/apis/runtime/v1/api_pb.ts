//
//Copyright 2020 The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// To regenerate api.pb.go run `hack/update-codegen.sh protobindings`

// @generated by protoc-gen-es v2.10.0 with parameter "target=ts"
// @generated from file cri-api/pkg/apis/runtime/v1/api.proto (package runtime.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file cri-api/pkg/apis/runtime/v1/api.proto.
 */
export const file_cri_api_pkg_apis_runtime_v1_api: GenFile = /*@__PURE__*/
  fileDesc("CiVjcmktYXBpL3BrZy9hcGlzL3J1bnRpbWUvdjEvYXBpLnByb3RvEgpydW50aW1lLnYxIiEKDlZlcnNpb25SZXF1ZXN0Eg8KB3ZlcnNpb24YASABKAkibgoPVmVyc2lvblJlc3BvbnNlEg8KB3ZlcnNpb24YASABKAkSFAoMcnVudGltZV9uYW1lGAIgASgJEhcKD3J1bnRpbWVfdmVyc2lvbhgDIAEoCRIbChNydW50aW1lX2FwaV92ZXJzaW9uGAQgASgJIj8KCUROU0NvbmZpZxIPCgdzZXJ2ZXJzGAEgAygJEhAKCHNlYXJjaGVzGAIgAygJEg8KB29wdGlvbnMYAyADKAkicQoLUG9ydE1hcHBpbmcSJgoIcHJvdG9jb2wYASABKA4yFC5ydW50aW1lLnYxLlByb3RvY29sEhYKDmNvbnRhaW5lcl9wb3J0GAIgASgFEhEKCWhvc3RfcG9ydBgDIAEoBRIPCgdob3N0X2lwGAQgASgJIsMCCgVNb3VudBIWCg5jb250YWluZXJfcGF0aBgBIAEoCRIRCglob3N0X3BhdGgYAiABKAkSEAoIcmVhZG9ubHkYAyABKAgSFwoPc2VsaW51eF9yZWxhYmVsGAQgASgIEjEKC3Byb3BhZ2F0aW9uGAUgASgOMhwucnVudGltZS52MS5Nb3VudFByb3BhZ2F0aW9uEioKC3VpZE1hcHBpbmdzGAYgAygLMhUucnVudGltZS52MS5JRE1hcHBpbmcSKgoLZ2lkTWFwcGluZ3MYByADKAsyFS5ydW50aW1lLnYxLklETWFwcGluZxIbChNyZWN1cnNpdmVfcmVhZF9vbmx5GAggASgIEiQKBWltYWdlGAkgASgLMhUucnVudGltZS52MS5JbWFnZVNwZWMSFgoOaW1hZ2Vfc3ViX3BhdGgYCiABKAkiQgoJSURNYXBwaW5nEg8KB2hvc3RfaWQYASABKA0SFAoMY29udGFpbmVyX2lkGAIgASgNEg4KBmxlbmd0aBgDIAEoDSKCAQoNVXNlck5hbWVzcGFjZRInCgRtb2RlGAEgASgOMhkucnVudGltZS52MS5OYW1lc3BhY2VNb2RlEiMKBHVpZHMYAiADKAsyFS5ydW50aW1lLnYxLklETWFwcGluZxIjCgRnaWRzGAMgAygLMhUucnVudGltZS52MS5JRE1hcHBpbmci0wEKD05hbWVzcGFjZU9wdGlvbhIqCgduZXR3b3JrGAEgASgOMhkucnVudGltZS52MS5OYW1lc3BhY2VNb2RlEiYKA3BpZBgCIAEoDjIZLnJ1bnRpbWUudjEuTmFtZXNwYWNlTW9kZRImCgNpcGMYAyABKA4yGS5ydW50aW1lLnYxLk5hbWVzcGFjZU1vZGUSEQoJdGFyZ2V0X2lkGAQgASgJEjEKDnVzZXJuc19vcHRpb25zGAUgASgLMhkucnVudGltZS52MS5Vc2VyTmFtZXNwYWNlIhsKCkludDY0VmFsdWUSDQoFdmFsdWUYASABKAMi9wMKG0xpbnV4U2FuZGJveFNlY3VyaXR5Q29udGV4dBI2ChFuYW1lc3BhY2Vfb3B0aW9ucxgBIAEoCzIbLnJ1bnRpbWUudjEuTmFtZXNwYWNlT3B0aW9uEjIKD3NlbGludXhfb3B0aW9ucxgCIAEoCzIZLnJ1bnRpbWUudjEuU0VMaW51eE9wdGlvbhIrCgtydW5fYXNfdXNlchgDIAEoCzIWLnJ1bnRpbWUudjEuSW50NjRWYWx1ZRIsCgxydW5fYXNfZ3JvdXAYCCABKAsyFi5ydW50aW1lLnYxLkludDY0VmFsdWUSFwoPcmVhZG9ubHlfcm9vdGZzGAQgASgIEhsKE3N1cHBsZW1lbnRhbF9ncm91cHMYBSADKAMSSAoac3VwcGxlbWVudGFsX2dyb3Vwc19wb2xpY3kYCyABKA4yJC5ydW50aW1lLnYxLlN1cHBsZW1lbnRhbEdyb3Vwc1BvbGljeRISCgpwcml2aWxlZ2VkGAYgASgIEiwKB3NlY2NvbXAYCSABKAsyGy5ydW50aW1lLnYxLlNlY3VyaXR5UHJvZmlsZRItCghhcHBhcm1vchgKIAEoCzIbLnJ1bnRpbWUudjEuU2VjdXJpdHlQcm9maWxlEiAKFHNlY2NvbXBfcHJvZmlsZV9wYXRoGAcgASgJQgIYASKpAQoPU2VjdXJpdHlQcm9maWxlEj0KDHByb2ZpbGVfdHlwZRgBIAEoDjInLnJ1bnRpbWUudjEuU2VjdXJpdHlQcm9maWxlLlByb2ZpbGVUeXBlEhUKDWxvY2FsaG9zdF9yZWYYAiABKAkiQAoLUHJvZmlsZVR5cGUSEgoOUnVudGltZURlZmF1bHQQABIOCgpVbmNvbmZpbmVkEAESDQoJTG9jYWxob3N0EAIi0QIKFUxpbnV4UG9kU2FuZGJveENvbmZpZxIVCg1jZ3JvdXBfcGFyZW50GAEgASgJEkEKEHNlY3VyaXR5X2NvbnRleHQYAiABKAsyJy5ydW50aW1lLnYxLkxpbnV4U2FuZGJveFNlY3VyaXR5Q29udGV4dBI/CgdzeXNjdGxzGAMgAygLMi4ucnVudGltZS52MS5MaW51eFBvZFNhbmRib3hDb25maWcuU3lzY3Rsc0VudHJ5EjUKCG92ZXJoZWFkGAQgASgLMiMucnVudGltZS52MS5MaW51eENvbnRhaW5lclJlc291cmNlcxI2CglyZXNvdXJjZXMYBSABKAsyIy5ydW50aW1lLnYxLkxpbnV4Q29udGFpbmVyUmVzb3VyY2VzGi4KDFN5c2N0bHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIlMKElBvZFNhbmRib3hNZXRhZGF0YRIMCgRuYW1lGAEgASgJEgsKA3VpZBgCIAEoCRIRCgluYW1lc3BhY2UYAyABKAkSDwoHYXR0ZW1wdBgEIAEoDSKRBAoQUG9kU2FuZGJveENvbmZpZxIwCghtZXRhZGF0YRgBIAEoCzIeLnJ1bnRpbWUudjEuUG9kU2FuZGJveE1ldGFkYXRhEhAKCGhvc3RuYW1lGAIgASgJEhUKDWxvZ19kaXJlY3RvcnkYAyABKAkSKQoKZG5zX2NvbmZpZxgEIAEoCzIVLnJ1bnRpbWUudjEuRE5TQ29uZmlnEi4KDXBvcnRfbWFwcGluZ3MYBSADKAsyFy5ydW50aW1lLnYxLlBvcnRNYXBwaW5nEjgKBmxhYmVscxgGIAMoCzIoLnJ1bnRpbWUudjEuUG9kU2FuZGJveENvbmZpZy5MYWJlbHNFbnRyeRJCCgthbm5vdGF0aW9ucxgHIAMoCzItLnJ1bnRpbWUudjEuUG9kU2FuZGJveENvbmZpZy5Bbm5vdGF0aW9uc0VudHJ5EjAKBWxpbnV4GAggASgLMiEucnVudGltZS52MS5MaW51eFBvZFNhbmRib3hDb25maWcSNAoHd2luZG93cxgJIAEoCzIjLnJ1bnRpbWUudjEuV2luZG93c1BvZFNhbmRib3hDb25maWcaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARoyChBBbm5vdGF0aW9uc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiXQoUUnVuUG9kU2FuZGJveFJlcXVlc3QSLAoGY29uZmlnGAEgASgLMhwucnVudGltZS52MS5Qb2RTYW5kYm94Q29uZmlnEhcKD3J1bnRpbWVfaGFuZGxlchgCIAEoCSIvChVSdW5Qb2RTYW5kYm94UmVzcG9uc2USFgoOcG9kX3NhbmRib3hfaWQYASABKAkiLwoVU3RvcFBvZFNhbmRib3hSZXF1ZXN0EhYKDnBvZF9zYW5kYm94X2lkGAEgASgJIhgKFlN0b3BQb2RTYW5kYm94UmVzcG9uc2UiMQoXUmVtb3ZlUG9kU2FuZGJveFJlcXVlc3QSFgoOcG9kX3NhbmRib3hfaWQYASABKAkiGgoYUmVtb3ZlUG9kU2FuZGJveFJlc3BvbnNlIkIKF1BvZFNhbmRib3hTdGF0dXNSZXF1ZXN0EhYKDnBvZF9zYW5kYm94X2lkGAEgASgJEg8KB3ZlcmJvc2UYAiABKAgiEwoFUG9kSVASCgoCaXAYASABKAkiUAoXUG9kU2FuZGJveE5ldHdvcmtTdGF0dXMSCgoCaXAYASABKAkSKQoOYWRkaXRpb25hbF9pcHMYAiADKAsyES5ydW50aW1lLnYxLlBvZElQIjkKCU5hbWVzcGFjZRIsCgdvcHRpb25zGAIgASgLMhsucnVudGltZS52MS5OYW1lc3BhY2VPcHRpb24iQgoVTGludXhQb2RTYW5kYm94U3RhdHVzEikKCm5hbWVzcGFjZXMYASABKAsyFS5ydW50aW1lLnYxLk5hbWVzcGFjZSLyAwoQUG9kU2FuZGJveFN0YXR1cxIKCgJpZBgBIAEoCRIwCghtZXRhZGF0YRgCIAEoCzIeLnJ1bnRpbWUudjEuUG9kU2FuZGJveE1ldGFkYXRhEioKBXN0YXRlGAMgASgOMhsucnVudGltZS52MS5Qb2RTYW5kYm94U3RhdGUSEgoKY3JlYXRlZF9hdBgEIAEoAxI0CgduZXR3b3JrGAUgASgLMiMucnVudGltZS52MS5Qb2RTYW5kYm94TmV0d29ya1N0YXR1cxIwCgVsaW51eBgGIAEoCzIhLnJ1bnRpbWUudjEuTGludXhQb2RTYW5kYm94U3RhdHVzEjgKBmxhYmVscxgHIAMoCzIoLnJ1bnRpbWUudjEuUG9kU2FuZGJveFN0YXR1cy5MYWJlbHNFbnRyeRJCCgthbm5vdGF0aW9ucxgIIAMoCzItLnJ1bnRpbWUudjEuUG9kU2FuZGJveFN0YXR1cy5Bbm5vdGF0aW9uc0VudHJ5EhcKD3J1bnRpbWVfaGFuZGxlchgJIAEoCRotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGjIKEEFubm90YXRpb25zRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKAAgoYUG9kU2FuZGJveFN0YXR1c1Jlc3BvbnNlEiwKBnN0YXR1cxgBIAEoCzIcLnJ1bnRpbWUudjEuUG9kU2FuZGJveFN0YXR1cxI8CgRpbmZvGAIgAygLMi4ucnVudGltZS52MS5Qb2RTYW5kYm94U3RhdHVzUmVzcG9uc2UuSW5mb0VudHJ5EjgKE2NvbnRhaW5lcnNfc3RhdHVzZXMYAyADKAsyGy5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXR1cxIRCgl0aW1lc3RhbXAYBCABKAMaKwoJSW5mb0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiQgoUUG9kU2FuZGJveFN0YXRlVmFsdWUSKgoFc3RhdGUYASABKA4yGy5ydW50aW1lLnYxLlBvZFNhbmRib3hTdGF0ZSLOAQoQUG9kU2FuZGJveEZpbHRlchIKCgJpZBgBIAEoCRIvCgVzdGF0ZRgCIAEoCzIgLnJ1bnRpbWUudjEuUG9kU2FuZGJveFN0YXRlVmFsdWUSRwoObGFiZWxfc2VsZWN0b3IYAyADKAsyLy5ydW50aW1lLnYxLlBvZFNhbmRib3hGaWx0ZXIuTGFiZWxTZWxlY3RvckVudHJ5GjQKEkxhYmVsU2VsZWN0b3JFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIkUKFUxpc3RQb2RTYW5kYm94UmVxdWVzdBIsCgZmaWx0ZXIYASABKAsyHC5ydW50aW1lLnYxLlBvZFNhbmRib3hGaWx0ZXIi+AIKClBvZFNhbmRib3gSCgoCaWQYASABKAkSMAoIbWV0YWRhdGEYAiABKAsyHi5ydW50aW1lLnYxLlBvZFNhbmRib3hNZXRhZGF0YRIqCgVzdGF0ZRgDIAEoDjIbLnJ1bnRpbWUudjEuUG9kU2FuZGJveFN0YXRlEhIKCmNyZWF0ZWRfYXQYBCABKAMSMgoGbGFiZWxzGAUgAygLMiIucnVudGltZS52MS5Qb2RTYW5kYm94LkxhYmVsc0VudHJ5EjwKC2Fubm90YXRpb25zGAYgAygLMicucnVudGltZS52MS5Qb2RTYW5kYm94LkFubm90YXRpb25zRW50cnkSFwoPcnVudGltZV9oYW5kbGVyGAcgASgJGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaMgoQQW5ub3RhdGlvbnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIj8KFkxpc3RQb2RTYW5kYm94UmVzcG9uc2USJQoFaXRlbXMYASADKAsyFi5ydW50aW1lLnYxLlBvZFNhbmRib3giMAoWUG9kU2FuZGJveFN0YXRzUmVxdWVzdBIWCg5wb2Rfc2FuZGJveF9pZBgBIAEoCSJFChdQb2RTYW5kYm94U3RhdHNSZXNwb25zZRIqCgVzdGF0cxgBIAEoCzIbLnJ1bnRpbWUudjEuUG9kU2FuZGJveFN0YXRzIqcBChVQb2RTYW5kYm94U3RhdHNGaWx0ZXISCgoCaWQYASABKAkSTAoObGFiZWxfc2VsZWN0b3IYAiADKAsyNC5ydW50aW1lLnYxLlBvZFNhbmRib3hTdGF0c0ZpbHRlci5MYWJlbFNlbGVjdG9yRW50cnkaNAoSTGFiZWxTZWxlY3RvckVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiTwoaTGlzdFBvZFNhbmRib3hTdGF0c1JlcXVlc3QSMQoGZmlsdGVyGAEgASgLMiEucnVudGltZS52MS5Qb2RTYW5kYm94U3RhdHNGaWx0ZXIiSQobTGlzdFBvZFNhbmRib3hTdGF0c1Jlc3BvbnNlEioKBXN0YXRzGAEgAygLMhsucnVudGltZS52MS5Qb2RTYW5kYm94U3RhdHMivQIKFFBvZFNhbmRib3hBdHRyaWJ1dGVzEgoKAmlkGAEgASgJEjAKCG1ldGFkYXRhGAIgASgLMh4ucnVudGltZS52MS5Qb2RTYW5kYm94TWV0YWRhdGESPAoGbGFiZWxzGAMgAygLMiwucnVudGltZS52MS5Qb2RTYW5kYm94QXR0cmlidXRlcy5MYWJlbHNFbnRyeRJGCgthbm5vdGF0aW9ucxgEIAMoCzIxLnJ1bnRpbWUudjEuUG9kU2FuZGJveEF0dHJpYnV0ZXMuQW5ub3RhdGlvbnNFbnRyeRotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGjIKEEFubm90YXRpb25zRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKtAQoPUG9kU2FuZGJveFN0YXRzEjQKCmF0dHJpYnV0ZXMYASABKAsyIC5ydW50aW1lLnYxLlBvZFNhbmRib3hBdHRyaWJ1dGVzEi8KBWxpbnV4GAIgASgLMiAucnVudGltZS52MS5MaW51eFBvZFNhbmRib3hTdGF0cxIzCgd3aW5kb3dzGAMgASgLMiIucnVudGltZS52MS5XaW5kb3dzUG9kU2FuZGJveFN0YXRzIokCChRMaW51eFBvZFNhbmRib3hTdGF0cxIhCgNjcHUYASABKAsyFC5ydW50aW1lLnYxLkNwdVVzYWdlEicKBm1lbW9yeRgCIAEoCzIXLnJ1bnRpbWUudjEuTWVtb3J5VXNhZ2USKQoHbmV0d29yaxgDIAEoCzIYLnJ1bnRpbWUudjEuTmV0d29ya1VzYWdlEikKB3Byb2Nlc3MYBCABKAsyGC5ydW50aW1lLnYxLlByb2Nlc3NVc2FnZRIuCgpjb250YWluZXJzGAUgAygLMhoucnVudGltZS52MS5Db250YWluZXJTdGF0cxIfCgJpbxgGIAEoCzITLnJ1bnRpbWUudjEuSW9Vc2FnZSKNAgoWV2luZG93c1BvZFNhbmRib3hTdGF0cxIoCgNjcHUYASABKAsyGy5ydW50aW1lLnYxLldpbmRvd3NDcHVVc2FnZRIuCgZtZW1vcnkYAiABKAsyHi5ydW50aW1lLnYxLldpbmRvd3NNZW1vcnlVc2FnZRIwCgduZXR3b3JrGAMgASgLMh8ucnVudGltZS52MS5XaW5kb3dzTmV0d29ya1VzYWdlEjAKB3Byb2Nlc3MYBCABKAsyHy5ydW50aW1lLnYxLldpbmRvd3NQcm9jZXNzVXNhZ2USNQoKY29udGFpbmVycxgFIAMoCzIhLnJ1bnRpbWUudjEuV2luZG93c0NvbnRhaW5lclN0YXRzIpYBCgxOZXR3b3JrVXNhZ2USEQoJdGltZXN0YW1wGAEgASgDEjwKEWRlZmF1bHRfaW50ZXJmYWNlGAIgASgLMiEucnVudGltZS52MS5OZXR3b3JrSW50ZXJmYWNlVXNhZ2USNQoKaW50ZXJmYWNlcxgDIAMoCzIhLnJ1bnRpbWUudjEuTmV0d29ya0ludGVyZmFjZVVzYWdlIqsBChNXaW5kb3dzTmV0d29ya1VzYWdlEhEKCXRpbWVzdGFtcBgBIAEoAxJDChFkZWZhdWx0X2ludGVyZmFjZRgCIAEoCzIoLnJ1bnRpbWUudjEuV2luZG93c05ldHdvcmtJbnRlcmZhY2VVc2FnZRI8CgppbnRlcmZhY2VzGAMgAygLMigucnVudGltZS52MS5XaW5kb3dzTmV0d29ya0ludGVyZmFjZVVzYWdlItMBChVOZXR3b3JrSW50ZXJmYWNlVXNhZ2USDAoEbmFtZRgBIAEoCRIpCghyeF9ieXRlcxgCIAEoCzIXLnJ1bnRpbWUudjEuVUludDY0VmFsdWUSKgoJcnhfZXJyb3JzGAMgASgLMhcucnVudGltZS52MS5VSW50NjRWYWx1ZRIpCgh0eF9ieXRlcxgEIAEoCzIXLnJ1bnRpbWUudjEuVUludDY0VmFsdWUSKgoJdHhfZXJyb3JzGAUgASgLMhcucnVudGltZS52MS5VSW50NjRWYWx1ZSLsAQocV2luZG93c05ldHdvcmtJbnRlcmZhY2VVc2FnZRIMCgRuYW1lGAEgASgJEikKCHJ4X2J5dGVzGAIgASgLMhcucnVudGltZS52MS5VSW50NjRWYWx1ZRIzChJyeF9wYWNrZXRzX2Ryb3BwZWQYAyABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlEikKCHR4X2J5dGVzGAQgASgLMhcucnVudGltZS52MS5VSW50NjRWYWx1ZRIzChJ0eF9wYWNrZXRzX2Ryb3BwZWQYBSABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlIlEKDFByb2Nlc3NVc2FnZRIRCgl0aW1lc3RhbXAYASABKAMSLgoNcHJvY2Vzc19jb3VudBgCIAEoCzIXLnJ1bnRpbWUudjEuVUludDY0VmFsdWUiWAoTV2luZG93c1Byb2Nlc3NVc2FnZRIRCgl0aW1lc3RhbXAYASABKAMSLgoNcHJvY2Vzc19jb3VudBgCIAEoCzIXLnJ1bnRpbWUudjEuVUludDY0VmFsdWUiwgEKCUltYWdlU3BlYxINCgVpbWFnZRgBIAEoCRI7Cgthbm5vdGF0aW9ucxgCIAMoCzImLnJ1bnRpbWUudjEuSW1hZ2VTcGVjLkFubm90YXRpb25zRW50cnkSHAoUdXNlcl9zcGVjaWZpZWRfaW1hZ2UYEiABKAkSFwoPcnVudGltZV9oYW5kbGVyGBMgASgJGjIKEEFubm90YXRpb25zRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASImCghLZXlWYWx1ZRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAki/wIKF0xpbnV4Q29udGFpbmVyUmVzb3VyY2VzEhIKCmNwdV9wZXJpb2QYASABKAMSEQoJY3B1X3F1b3RhGAIgASgDEhIKCmNwdV9zaGFyZXMYAyABKAMSHQoVbWVtb3J5X2xpbWl0X2luX2J5dGVzGAQgASgDEhUKDW9vbV9zY29yZV9hZGoYBSABKAMSEwoLY3B1c2V0X2NwdXMYBiABKAkSEwoLY3B1c2V0X21lbXMYByABKAkSMgoPaHVnZXBhZ2VfbGltaXRzGAggAygLMhkucnVudGltZS52MS5IdWdlcGFnZUxpbWl0EkEKB3VuaWZpZWQYCSADKAsyMC5ydW50aW1lLnYxLkxpbnV4Q29udGFpbmVyUmVzb3VyY2VzLlVuaWZpZWRFbnRyeRIiChptZW1vcnlfc3dhcF9saW1pdF9pbl9ieXRlcxgKIAEoAxouCgxVbmlmaWVkRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASIxCg1IdWdlcGFnZUxpbWl0EhEKCXBhZ2Vfc2l6ZRgBIAEoCRINCgVsaW1pdBgCIAEoBCJICg1TRUxpbnV4T3B0aW9uEgwKBHVzZXIYASABKAkSDAoEcm9sZRgCIAEoCRIMCgR0eXBlGAMgASgJEg0KBWxldmVsGAQgASgJImMKCkNhcGFiaWxpdHkSGAoQYWRkX2NhcGFiaWxpdGllcxgBIAMoCRIZChFkcm9wX2NhcGFiaWxpdGllcxgCIAMoCRIgChhhZGRfYW1iaWVudF9jYXBhYmlsaXRpZXMYAyADKAkiogUKHUxpbnV4Q29udGFpbmVyU2VjdXJpdHlDb250ZXh0EiwKDGNhcGFiaWxpdGllcxgBIAEoCzIWLnJ1bnRpbWUudjEuQ2FwYWJpbGl0eRISCgpwcml2aWxlZ2VkGAIgASgIEjYKEW5hbWVzcGFjZV9vcHRpb25zGAMgASgLMhsucnVudGltZS52MS5OYW1lc3BhY2VPcHRpb24SMgoPc2VsaW51eF9vcHRpb25zGAQgASgLMhkucnVudGltZS52MS5TRUxpbnV4T3B0aW9uEisKC3J1bl9hc191c2VyGAUgASgLMhYucnVudGltZS52MS5JbnQ2NFZhbHVlEiwKDHJ1bl9hc19ncm91cBgMIAEoCzIWLnJ1bnRpbWUudjEuSW50NjRWYWx1ZRIXCg9ydW5fYXNfdXNlcm5hbWUYBiABKAkSFwoPcmVhZG9ubHlfcm9vdGZzGAcgASgIEhsKE3N1cHBsZW1lbnRhbF9ncm91cHMYCCADKAMSSAoac3VwcGxlbWVudGFsX2dyb3Vwc19wb2xpY3kYESABKA4yJC5ydW50aW1lLnYxLlN1cHBsZW1lbnRhbEdyb3Vwc1BvbGljeRIUCgxub19uZXdfcHJpdnMYCyABKAgSFAoMbWFza2VkX3BhdGhzGA0gAygJEhYKDnJlYWRvbmx5X3BhdGhzGA4gAygJEiwKB3NlY2NvbXAYDyABKAsyGy5ydW50aW1lLnYxLlNlY3VyaXR5UHJvZmlsZRItCghhcHBhcm1vchgQIAEoCzIbLnJ1bnRpbWUudjEuU2VjdXJpdHlQcm9maWxlEhwKEGFwcGFybW9yX3Byb2ZpbGUYCSABKAlCAhgBEiAKFHNlY2NvbXBfcHJvZmlsZV9wYXRoGAogASgJQgIYASKTAQoUTGludXhDb250YWluZXJDb25maWcSNgoJcmVzb3VyY2VzGAEgASgLMiMucnVudGltZS52MS5MaW51eENvbnRhaW5lclJlc291cmNlcxJDChBzZWN1cml0eV9jb250ZXh0GAIgASgLMikucnVudGltZS52MS5MaW51eENvbnRhaW5lclNlY3VyaXR5Q29udGV4dCJLChJMaW51eENvbnRhaW5lclVzZXISCwoDdWlkGAEgASgDEgsKA2dpZBgCIAEoAxIbChNzdXBwbGVtZW50YWxfZ3JvdXBzGAMgAygDIkQKFldpbmRvd3NOYW1lc3BhY2VPcHRpb24SKgoHbmV0d29yaxgBIAEoDjIZLnJ1bnRpbWUudjEuTmFtZXNwYWNlTW9kZSKmAQodV2luZG93c1NhbmRib3hTZWN1cml0eUNvbnRleHQSFwoPcnVuX2FzX3VzZXJuYW1lGAEgASgJEhcKD2NyZWRlbnRpYWxfc3BlYxgCIAEoCRIUCgxob3N0X3Byb2Nlc3MYAyABKAgSPQoRbmFtZXNwYWNlX29wdGlvbnMYBCABKAsyIi5ydW50aW1lLnYxLldpbmRvd3NOYW1lc3BhY2VPcHRpb24iXgoXV2luZG93c1BvZFNhbmRib3hDb25maWcSQwoQc2VjdXJpdHlfY29udGV4dBgBIAEoCzIpLnJ1bnRpbWUudjEuV2luZG93c1NhbmRib3hTZWN1cml0eUNvbnRleHQiaQofV2luZG93c0NvbnRhaW5lclNlY3VyaXR5Q29udGV4dBIXCg9ydW5fYXNfdXNlcm5hbWUYASABKAkSFwoPY3JlZGVudGlhbF9zcGVjGAIgASgJEhQKDGhvc3RfcHJvY2VzcxgDIAEoCCKZAQoWV2luZG93c0NvbnRhaW5lckNvbmZpZxI4CglyZXNvdXJjZXMYASABKAsyJS5ydW50aW1lLnYxLldpbmRvd3NDb250YWluZXJSZXNvdXJjZXMSRQoQc2VjdXJpdHlfY29udGV4dBgCIAEoCzIrLnJ1bnRpbWUudjEuV2luZG93c0NvbnRhaW5lclNlY3VyaXR5Q29udGV4dCLQAQoZV2luZG93c0NvbnRhaW5lclJlc291cmNlcxISCgpjcHVfc2hhcmVzGAEgASgDEhEKCWNwdV9jb3VudBgCIAEoAxITCgtjcHVfbWF4aW11bRgDIAEoAxIdChVtZW1vcnlfbGltaXRfaW5fYnl0ZXMYBCABKAMSHAoUcm9vdGZzX3NpemVfaW5fYnl0ZXMYBSABKAMSOgoNYWZmaW5pdHlfY3B1cxgGIAMoCzIjLnJ1bnRpbWUudjEuV2luZG93c0NwdUdyb3VwQWZmaW5pdHkiPgoXV2luZG93c0NwdUdyb3VwQWZmaW5pdHkSEAoIY3B1X21hc2sYASABKAQSEQoJY3B1X2dyb3VwGAIgASgNIjIKEUNvbnRhaW5lck1ldGFkYXRhEgwKBG5hbWUYASABKAkSDwoHYXR0ZW1wdBgCIAEoDSJICgZEZXZpY2USFgoOY29udGFpbmVyX3BhdGgYASABKAkSEQoJaG9zdF9wYXRoGAIgASgJEhMKC3Blcm1pc3Npb25zGAMgASgJIhkKCUNESURldmljZRIMCgRuYW1lGAEgASgJIuQFCg9Db250YWluZXJDb25maWcSLwoIbWV0YWRhdGEYASABKAsyHS5ydW50aW1lLnYxLkNvbnRhaW5lck1ldGFkYXRhEiQKBWltYWdlGAIgASgLMhUucnVudGltZS52MS5JbWFnZVNwZWMSDwoHY29tbWFuZBgDIAMoCRIMCgRhcmdzGAQgAygJEhMKC3dvcmtpbmdfZGlyGAUgASgJEiIKBGVudnMYBiADKAsyFC5ydW50aW1lLnYxLktleVZhbHVlEiEKBm1vdW50cxgHIAMoCzIRLnJ1bnRpbWUudjEuTW91bnQSIwoHZGV2aWNlcxgIIAMoCzISLnJ1bnRpbWUudjEuRGV2aWNlEjcKBmxhYmVscxgJIAMoCzInLnJ1bnRpbWUudjEuQ29udGFpbmVyQ29uZmlnLkxhYmVsc0VudHJ5EkEKC2Fubm90YXRpb25zGAogAygLMiwucnVudGltZS52MS5Db250YWluZXJDb25maWcuQW5ub3RhdGlvbnNFbnRyeRIQCghsb2dfcGF0aBgLIAEoCRINCgVzdGRpbhgMIAEoCBISCgpzdGRpbl9vbmNlGA0gASgIEgsKA3R0eRgOIAEoCBIvCgVsaW51eBgPIAEoCzIgLnJ1bnRpbWUudjEuTGludXhDb250YWluZXJDb25maWcSMwoHd2luZG93cxgQIAEoCzIiLnJ1bnRpbWUudjEuV2luZG93c0NvbnRhaW5lckNvbmZpZxIqCgtDRElfZGV2aWNlcxgRIAMoCzIVLnJ1bnRpbWUudjEuQ0RJRGV2aWNlEicKC3N0b3Bfc2lnbmFsGBIgASgOMhIucnVudGltZS52MS5TaWduYWwaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARoyChBBbm5vdGF0aW9uc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEikwEKFkNyZWF0ZUNvbnRhaW5lclJlcXVlc3QSFgoOcG9kX3NhbmRib3hfaWQYASABKAkSKwoGY29uZmlnGAIgASgLMhsucnVudGltZS52MS5Db250YWluZXJDb25maWcSNAoOc2FuZGJveF9jb25maWcYAyABKAsyHC5ydW50aW1lLnYxLlBvZFNhbmRib3hDb25maWciLwoXQ3JlYXRlQ29udGFpbmVyUmVzcG9uc2USFAoMY29udGFpbmVyX2lkGAEgASgJIi0KFVN0YXJ0Q29udGFpbmVyUmVxdWVzdBIUCgxjb250YWluZXJfaWQYASABKAkiGAoWU3RhcnRDb250YWluZXJSZXNwb25zZSI9ChRTdG9wQ29udGFpbmVyUmVxdWVzdBIUCgxjb250YWluZXJfaWQYASABKAkSDwoHdGltZW91dBgCIAEoAyIXChVTdG9wQ29udGFpbmVyUmVzcG9uc2UiLgoWUmVtb3ZlQ29udGFpbmVyUmVxdWVzdBIUCgxjb250YWluZXJfaWQYASABKAkiGQoXUmVtb3ZlQ29udGFpbmVyUmVzcG9uc2UiQAoTQ29udGFpbmVyU3RhdGVWYWx1ZRIpCgVzdGF0ZRgBIAEoDjIaLnJ1bnRpbWUudjEuQ29udGFpbmVyU3RhdGUi4wEKD0NvbnRhaW5lckZpbHRlchIKCgJpZBgBIAEoCRIuCgVzdGF0ZRgCIAEoCzIfLnJ1bnRpbWUudjEuQ29udGFpbmVyU3RhdGVWYWx1ZRIWCg5wb2Rfc2FuZGJveF9pZBgDIAEoCRJGCg5sYWJlbF9zZWxlY3RvchgEIAMoCzIuLnJ1bnRpbWUudjEuQ29udGFpbmVyRmlsdGVyLkxhYmVsU2VsZWN0b3JFbnRyeRo0ChJMYWJlbFNlbGVjdG9yRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJEChVMaXN0Q29udGFpbmVyc1JlcXVlc3QSKwoGZmlsdGVyGAEgASgLMhsucnVudGltZS52MS5Db250YWluZXJGaWx0ZXIivQMKCUNvbnRhaW5lchIKCgJpZBgBIAEoCRIWCg5wb2Rfc2FuZGJveF9pZBgCIAEoCRIvCghtZXRhZGF0YRgDIAEoCzIdLnJ1bnRpbWUudjEuQ29udGFpbmVyTWV0YWRhdGESJAoFaW1hZ2UYBCABKAsyFS5ydW50aW1lLnYxLkltYWdlU3BlYxIRCglpbWFnZV9yZWYYBSABKAkSKQoFc3RhdGUYBiABKA4yGi5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXRlEhIKCmNyZWF0ZWRfYXQYByABKAMSMQoGbGFiZWxzGAggAygLMiEucnVudGltZS52MS5Db250YWluZXIuTGFiZWxzRW50cnkSOwoLYW5ub3RhdGlvbnMYCSADKAsyJi5ydW50aW1lLnYxLkNvbnRhaW5lci5Bbm5vdGF0aW9uc0VudHJ5EhAKCGltYWdlX2lkGAogASgJGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaMgoQQW5ub3RhdGlvbnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIkMKFkxpc3RDb250YWluZXJzUmVzcG9uc2USKQoKY29udGFpbmVycxgBIAMoCzIVLnJ1bnRpbWUudjEuQ29udGFpbmVyIj8KFkNvbnRhaW5lclN0YXR1c1JlcXVlc3QSFAoMY29udGFpbmVyX2lkGAEgASgJEg8KB3ZlcmJvc2UYAiABKAgizgUKD0NvbnRhaW5lclN0YXR1cxIKCgJpZBgBIAEoCRIvCghtZXRhZGF0YRgCIAEoCzIdLnJ1bnRpbWUudjEuQ29udGFpbmVyTWV0YWRhdGESKQoFc3RhdGUYAyABKA4yGi5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXRlEhIKCmNyZWF0ZWRfYXQYBCABKAMSEgoKc3RhcnRlZF9hdBgFIAEoAxITCgtmaW5pc2hlZF9hdBgGIAEoAxIRCglleGl0X2NvZGUYByABKAUSJAoFaW1hZ2UYCCABKAsyFS5ydW50aW1lLnYxLkltYWdlU3BlYxIRCglpbWFnZV9yZWYYCSABKAkSDgoGcmVhc29uGAogASgJEg8KB21lc3NhZ2UYCyABKAkSNwoGbGFiZWxzGAwgAygLMicucnVudGltZS52MS5Db250YWluZXJTdGF0dXMuTGFiZWxzRW50cnkSQQoLYW5ub3RhdGlvbnMYDSADKAsyLC5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXR1cy5Bbm5vdGF0aW9uc0VudHJ5EiEKBm1vdW50cxgOIAMoCzIRLnJ1bnRpbWUudjEuTW91bnQSEAoIbG9nX3BhdGgYDyABKAkSMQoJcmVzb3VyY2VzGBAgASgLMh4ucnVudGltZS52MS5Db250YWluZXJSZXNvdXJjZXMSEAoIaW1hZ2VfaWQYESABKAkSJwoEdXNlchgSIAEoCzIZLnJ1bnRpbWUudjEuQ29udGFpbmVyVXNlchInCgtzdG9wX3NpZ25hbBgTIAEoDjISLnJ1bnRpbWUudjEuU2lnbmFsGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaMgoQQW5ub3RhdGlvbnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIrABChdDb250YWluZXJTdGF0dXNSZXNwb25zZRIrCgZzdGF0dXMYASABKAsyGy5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXR1cxI7CgRpbmZvGAIgAygLMi0ucnVudGltZS52MS5Db250YWluZXJTdGF0dXNSZXNwb25zZS5JbmZvRW50cnkaKwoJSW5mb0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEigAEKEkNvbnRhaW5lclJlc291cmNlcxIyCgVsaW51eBgBIAEoCzIjLnJ1bnRpbWUudjEuTGludXhDb250YWluZXJSZXNvdXJjZXMSNgoHd2luZG93cxgCIAEoCzIlLnJ1bnRpbWUudjEuV2luZG93c0NvbnRhaW5lclJlc291cmNlcyI+Cg1Db250YWluZXJVc2VyEi0KBWxpbnV4GAEgASgLMh4ucnVudGltZS52MS5MaW51eENvbnRhaW5lclVzZXIiqgIKH1VwZGF0ZUNvbnRhaW5lclJlc291cmNlc1JlcXVlc3QSFAoMY29udGFpbmVyX2lkGAEgASgJEjIKBWxpbnV4GAIgASgLMiMucnVudGltZS52MS5MaW51eENvbnRhaW5lclJlc291cmNlcxI2Cgd3aW5kb3dzGAMgASgLMiUucnVudGltZS52MS5XaW5kb3dzQ29udGFpbmVyUmVzb3VyY2VzElEKC2Fubm90YXRpb25zGAQgAygLMjwucnVudGltZS52MS5VcGRhdGVDb250YWluZXJSZXNvdXJjZXNSZXF1ZXN0LkFubm90YXRpb25zRW50cnkaMgoQQW5ub3RhdGlvbnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIiIKIFVwZGF0ZUNvbnRhaW5lclJlc291cmNlc1Jlc3BvbnNlIkUKD0V4ZWNTeW5jUmVxdWVzdBIUCgxjb250YWluZXJfaWQYASABKAkSCwoDY21kGAIgAygJEg8KB3RpbWVvdXQYAyABKAMiRQoQRXhlY1N5bmNSZXNwb25zZRIOCgZzdGRvdXQYASABKAwSDgoGc3RkZXJyGAIgASgMEhEKCWV4aXRfY29kZRgDIAEoBSJsCgtFeGVjUmVxdWVzdBIUCgxjb250YWluZXJfaWQYASABKAkSCwoDY21kGAIgAygJEgsKA3R0eRgDIAEoCBINCgVzdGRpbhgEIAEoCBIOCgZzdGRvdXQYBSABKAgSDgoGc3RkZXJyGAYgASgIIhsKDEV4ZWNSZXNwb25zZRILCgN1cmwYASABKAkiYQoNQXR0YWNoUmVxdWVzdBIUCgxjb250YWluZXJfaWQYASABKAkSDQoFc3RkaW4YAiABKAgSCwoDdHR5GAMgASgIEg4KBnN0ZG91dBgEIAEoCBIOCgZzdGRlcnIYBSABKAgiHQoOQXR0YWNoUmVzcG9uc2USCwoDdXJsGAEgASgJIjoKElBvcnRGb3J3YXJkUmVxdWVzdBIWCg5wb2Rfc2FuZGJveF9pZBgBIAEoCRIMCgRwb3J0GAIgAygFIiIKE1BvcnRGb3J3YXJkUmVzcG9uc2USCwoDdXJsGAEgASgJIjMKC0ltYWdlRmlsdGVyEiQKBWltYWdlGAEgASgLMhUucnVudGltZS52MS5JbWFnZVNwZWMiPAoRTGlzdEltYWdlc1JlcXVlc3QSJwoGZmlsdGVyGAEgASgLMhcucnVudGltZS52MS5JbWFnZUZpbHRlciK2AQoFSW1hZ2USCgoCaWQYASABKAkSEQoJcmVwb190YWdzGAIgAygJEhQKDHJlcG9fZGlnZXN0cxgDIAMoCRIMCgRzaXplGAQgASgEEiMKA3VpZBgFIAEoCzIWLnJ1bnRpbWUudjEuSW50NjRWYWx1ZRIQCgh1c2VybmFtZRgGIAEoCRIjCgRzcGVjGAcgASgLMhUucnVudGltZS52MS5JbWFnZVNwZWMSDgoGcGlubmVkGAggASgIIjcKEkxpc3RJbWFnZXNSZXNwb25zZRIhCgZpbWFnZXMYASADKAsyES5ydW50aW1lLnYxLkltYWdlIksKEkltYWdlU3RhdHVzUmVxdWVzdBIkCgVpbWFnZRgBIAEoCzIVLnJ1bnRpbWUudjEuSW1hZ2VTcGVjEg8KB3ZlcmJvc2UYAiABKAginQEKE0ltYWdlU3RhdHVzUmVzcG9uc2USIAoFaW1hZ2UYASABKAsyES5ydW50aW1lLnYxLkltYWdlEjcKBGluZm8YAiADKAsyKS5ydW50aW1lLnYxLkltYWdlU3RhdHVzUmVzcG9uc2UuSW5mb0VudHJ5GisKCUluZm9FbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIpoBCgpBdXRoQ29uZmlnEhAKCHVzZXJuYW1lGAEgASgJEhUKCHBhc3N3b3JkGAIgASgJQgOAAQESEQoEYXV0aBgDIAEoCUIDgAEBEhYKDnNlcnZlcl9hZGRyZXNzGAQgASgJEhsKDmlkZW50aXR5X3Rva2VuGAUgASgJQgOAAQESGwoOcmVnaXN0cnlfdG9rZW4YBiABKAlCA4ABASKUAQoQUHVsbEltYWdlUmVxdWVzdBIkCgVpbWFnZRgBIAEoCzIVLnJ1bnRpbWUudjEuSW1hZ2VTcGVjEiQKBGF1dGgYAiABKAsyFi5ydW50aW1lLnYxLkF1dGhDb25maWcSNAoOc2FuZGJveF9jb25maWcYAyABKAsyHC5ydW50aW1lLnYxLlBvZFNhbmRib3hDb25maWciJgoRUHVsbEltYWdlUmVzcG9uc2USEQoJaW1hZ2VfcmVmGAEgASgJIjoKElJlbW92ZUltYWdlUmVxdWVzdBIkCgVpbWFnZRgBIAEoCzIVLnJ1bnRpbWUudjEuSW1hZ2VTcGVjIhUKE1JlbW92ZUltYWdlUmVzcG9uc2UiIQoNTmV0d29ya0NvbmZpZxIQCghwb2RfY2lkchgBIAEoCSJCCg1SdW50aW1lQ29uZmlnEjEKDm5ldHdvcmtfY29uZmlnGAEgASgLMhkucnVudGltZS52MS5OZXR3b3JrQ29uZmlnIk8KGlVwZGF0ZVJ1bnRpbWVDb25maWdSZXF1ZXN0EjEKDnJ1bnRpbWVfY29uZmlnGAEgASgLMhkucnVudGltZS52MS5SdW50aW1lQ29uZmlnIh0KG1VwZGF0ZVJ1bnRpbWVDb25maWdSZXNwb25zZSJRChBSdW50aW1lQ29uZGl0aW9uEgwKBHR5cGUYASABKAkSDgoGc3RhdHVzGAIgASgIEg4KBnJlYXNvbhgDIAEoCRIPCgdtZXNzYWdlGAQgASgJIkEKDVJ1bnRpbWVTdGF0dXMSMAoKY29uZGl0aW9ucxgBIAMoCzIcLnJ1bnRpbWUudjEuUnVudGltZUNvbmRpdGlvbiIgCg1TdGF0dXNSZXF1ZXN0Eg8KB3ZlcmJvc2UYASABKAgiVQoWUnVudGltZUhhbmRsZXJGZWF0dXJlcxIiChpyZWN1cnNpdmVfcmVhZF9vbmx5X21vdW50cxgBIAEoCBIXCg91c2VyX25hbWVzcGFjZXMYAiABKAgiVAoOUnVudGltZUhhbmRsZXISDAoEbmFtZRgBIAEoCRI0CghmZWF0dXJlcxgCIAEoCzIiLnJ1bnRpbWUudjEuUnVudGltZUhhbmRsZXJGZWF0dXJlcyI1Cg9SdW50aW1lRmVhdHVyZXMSIgoac3VwcGxlbWVudGFsX2dyb3Vwc19wb2xpY3kYASABKAgigQIKDlN0YXR1c1Jlc3BvbnNlEikKBnN0YXR1cxgBIAEoCzIZLnJ1bnRpbWUudjEuUnVudGltZVN0YXR1cxIyCgRpbmZvGAIgAygLMiQucnVudGltZS52MS5TdGF0dXNSZXNwb25zZS5JbmZvRW50cnkSNAoQcnVudGltZV9oYW5kbGVycxgDIAMoCzIaLnJ1bnRpbWUudjEuUnVudGltZUhhbmRsZXISLQoIZmVhdHVyZXMYBCABKAsyGy5ydW50aW1lLnYxLlJ1bnRpbWVGZWF0dXJlcxorCglJbmZvRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASIUChJJbWFnZUZzSW5mb1JlcXVlc3QiHAoLVUludDY0VmFsdWUSDQoFdmFsdWUYASABKAQiKgoURmlsZXN5c3RlbUlkZW50aWZpZXISEgoKbW91bnRwb2ludBgBIAEoCSKwAQoPRmlsZXN5c3RlbVVzYWdlEhEKCXRpbWVzdGFtcBgBIAEoAxIvCgVmc19pZBgCIAEoCzIgLnJ1bnRpbWUudjEuRmlsZXN5c3RlbUlkZW50aWZpZXISKwoKdXNlZF9ieXRlcxgDIAEoCzIXLnJ1bnRpbWUudjEuVUludDY0VmFsdWUSLAoLaW5vZGVzX3VzZWQYBCABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlIokBChZXaW5kb3dzRmlsZXN5c3RlbVVzYWdlEhEKCXRpbWVzdGFtcBgBIAEoAxIvCgVmc19pZBgCIAEoCzIgLnJ1bnRpbWUudjEuRmlsZXN5c3RlbUlkZW50aWZpZXISKwoKdXNlZF9ieXRlcxgDIAEoCzIXLnJ1bnRpbWUudjEuVUludDY0VmFsdWUiiQEKE0ltYWdlRnNJbmZvUmVzcG9uc2USNgoRaW1hZ2VfZmlsZXN5c3RlbXMYASADKAsyGy5ydW50aW1lLnYxLkZpbGVzeXN0ZW1Vc2FnZRI6ChVjb250YWluZXJfZmlsZXN5c3RlbXMYAiADKAsyGy5ydW50aW1lLnYxLkZpbGVzeXN0ZW1Vc2FnZSItChVDb250YWluZXJTdGF0c1JlcXVlc3QSFAoMY29udGFpbmVyX2lkGAEgASgJIkMKFkNvbnRhaW5lclN0YXRzUmVzcG9uc2USKQoFc3RhdHMYASABKAsyGi5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXRzIk0KGUxpc3RDb250YWluZXJTdGF0c1JlcXVlc3QSMAoGZmlsdGVyGAEgASgLMiAucnVudGltZS52MS5Db250YWluZXJTdGF0c0ZpbHRlciK9AQoUQ29udGFpbmVyU3RhdHNGaWx0ZXISCgoCaWQYASABKAkSFgoOcG9kX3NhbmRib3hfaWQYAiABKAkSSwoObGFiZWxfc2VsZWN0b3IYAyADKAsyMy5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXRzRmlsdGVyLkxhYmVsU2VsZWN0b3JFbnRyeRo0ChJMYWJlbFNlbGVjdG9yRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJHChpMaXN0Q29udGFpbmVyU3RhdHNSZXNwb25zZRIpCgVzdGF0cxgBIAMoCzIaLnJ1bnRpbWUudjEuQ29udGFpbmVyU3RhdHMiuQIKE0NvbnRhaW5lckF0dHJpYnV0ZXMSCgoCaWQYASABKAkSLwoIbWV0YWRhdGEYAiABKAsyHS5ydW50aW1lLnYxLkNvbnRhaW5lck1ldGFkYXRhEjsKBmxhYmVscxgDIAMoCzIrLnJ1bnRpbWUudjEuQ29udGFpbmVyQXR0cmlidXRlcy5MYWJlbHNFbnRyeRJFCgthbm5vdGF0aW9ucxgEIAMoCzIwLnJ1bnRpbWUudjEuQ29udGFpbmVyQXR0cmlidXRlcy5Bbm5vdGF0aW9uc0VudHJ5Gi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaMgoQQW5ub3RhdGlvbnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIowCCg5Db250YWluZXJTdGF0cxIzCgphdHRyaWJ1dGVzGAEgASgLMh8ucnVudGltZS52MS5Db250YWluZXJBdHRyaWJ1dGVzEiEKA2NwdRgCIAEoCzIULnJ1bnRpbWUudjEuQ3B1VXNhZ2USJwoGbWVtb3J5GAMgASgLMhcucnVudGltZS52MS5NZW1vcnlVc2FnZRIzCg53cml0YWJsZV9sYXllchgEIAEoCzIbLnJ1bnRpbWUudjEuRmlsZXN5c3RlbVVzYWdlEiMKBHN3YXAYBSABKAsyFS5ydW50aW1lLnYxLlN3YXBVc2FnZRIfCgJpbxgGIAEoCzITLnJ1bnRpbWUudjEuSW9Vc2FnZSLiAQoVV2luZG93c0NvbnRhaW5lclN0YXRzEjMKCmF0dHJpYnV0ZXMYASABKAsyHy5ydW50aW1lLnYxLkNvbnRhaW5lckF0dHJpYnV0ZXMSKAoDY3B1GAIgASgLMhsucnVudGltZS52MS5XaW5kb3dzQ3B1VXNhZ2USLgoGbWVtb3J5GAMgASgLMh4ucnVudGltZS52MS5XaW5kb3dzTWVtb3J5VXNhZ2USOgoOd3JpdGFibGVfbGF5ZXIYBCABKAsyIi5ydW50aW1lLnYxLldpbmRvd3NGaWxlc3lzdGVtVXNhZ2UiUAoIUHNpU3RhdHMSIQoERnVsbBgBIAEoCzITLnJ1bnRpbWUudjEuUHNpRGF0YRIhCgRTb21lGAIgASgLMhMucnVudGltZS52MS5Qc2lEYXRhIkYKB1BzaURhdGESDQoFVG90YWwYASABKAQSDQoFQXZnMTAYAiABKAESDQoFQXZnNjAYAyABKAESDgoGQXZnMzAwGAQgASgBIq0BCghDcHVVc2FnZRIRCgl0aW1lc3RhbXAYASABKAMSOAoXdXNhZ2VfY29yZV9uYW5vX3NlY29uZHMYAiABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlEjEKEHVzYWdlX25hbm9fY29yZXMYAyABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlEiEKA3BzaRgEIAEoCzIULnJ1bnRpbWUudjEuUHNpU3RhdHMikQEKD1dpbmRvd3NDcHVVc2FnZRIRCgl0aW1lc3RhbXAYASABKAMSOAoXdXNhZ2VfY29yZV9uYW5vX3NlY29uZHMYAiABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlEjEKEHVzYWdlX25hbm9fY29yZXMYAyABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlIuUCCgtNZW1vcnlVc2FnZRIRCgl0aW1lc3RhbXAYASABKAMSMgoRd29ya2luZ19zZXRfYnl0ZXMYAiABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlEjAKD2F2YWlsYWJsZV9ieXRlcxgDIAEoCzIXLnJ1bnRpbWUudjEuVUludDY0VmFsdWUSLAoLdXNhZ2VfYnl0ZXMYBCABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlEioKCXJzc19ieXRlcxgFIAEoCzIXLnJ1bnRpbWUudjEuVUludDY0VmFsdWUSLAoLcGFnZV9mYXVsdHMYBiABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlEjIKEW1ham9yX3BhZ2VfZmF1bHRzGAcgASgLMhcucnVudGltZS52MS5VSW50NjRWYWx1ZRIhCgNwc2kYCCABKAsyFC5ydW50aW1lLnYxLlBzaVN0YXRzIj8KB0lvVXNhZ2USEQoJdGltZXN0YW1wGAEgASgDEiEKA3BzaRgCIAEoCzIULnJ1bnRpbWUudjEuUHNpU3RhdHMiiAEKCVN3YXBVc2FnZRIRCgl0aW1lc3RhbXAYASABKAMSNQoUc3dhcF9hdmFpbGFibGVfYnl0ZXMYAiABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlEjEKEHN3YXBfdXNhZ2VfYnl0ZXMYAyABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlIvEBChJXaW5kb3dzTWVtb3J5VXNhZ2USEQoJdGltZXN0YW1wGAEgASgDEjIKEXdvcmtpbmdfc2V0X2J5dGVzGAIgASgLMhcucnVudGltZS52MS5VSW50NjRWYWx1ZRIwCg9hdmFpbGFibGVfYnl0ZXMYAyABKAsyFy5ydW50aW1lLnYxLlVJbnQ2NFZhbHVlEiwKC3BhZ2VfZmF1bHRzGAQgASgLMhcucnVudGltZS52MS5VSW50NjRWYWx1ZRI0ChNjb21taXRfbWVtb3J5X2J5dGVzGAUgASgLMhcucnVudGltZS52MS5VSW50NjRWYWx1ZSIxChlSZW9wZW5Db250YWluZXJMb2dSZXF1ZXN0EhQKDGNvbnRhaW5lcl9pZBgBIAEoCSIcChpSZW9wZW5Db250YWluZXJMb2dSZXNwb25zZSJVChpDaGVja3BvaW50Q29udGFpbmVyUmVxdWVzdBIUCgxjb250YWluZXJfaWQYASABKAkSEAoIbG9jYXRpb24YAiABKAkSDwoHdGltZW91dBgDIAEoAyIdChtDaGVja3BvaW50Q29udGFpbmVyUmVzcG9uc2UiEgoQR2V0RXZlbnRzUmVxdWVzdCL0AQoWQ29udGFpbmVyRXZlbnRSZXNwb25zZRIUCgxjb250YWluZXJfaWQYASABKAkSPAoUY29udGFpbmVyX2V2ZW50X3R5cGUYAiABKA4yHi5ydW50aW1lLnYxLkNvbnRhaW5lckV2ZW50VHlwZRISCgpjcmVhdGVkX2F0GAMgASgDEjgKEnBvZF9zYW5kYm94X3N0YXR1cxgEIAEoCzIcLnJ1bnRpbWUudjEuUG9kU2FuZGJveFN0YXR1cxI4ChNjb250YWluZXJzX3N0YXR1c2VzGAUgAygLMhsucnVudGltZS52MS5Db250YWluZXJTdGF0dXMiHgocTGlzdE1ldHJpY0Rlc2NyaXB0b3JzUmVxdWVzdCJSCh1MaXN0TWV0cmljRGVzY3JpcHRvcnNSZXNwb25zZRIxCgtkZXNjcmlwdG9ycxgBIAMoCzIcLnJ1bnRpbWUudjEuTWV0cmljRGVzY3JpcHRvciJCChBNZXRyaWNEZXNjcmlwdG9yEgwKBG5hbWUYASABKAkSDAoEaGVscBgCIAEoCRISCgpsYWJlbF9rZXlzGAMgAygJIh4KHExpc3RQb2RTYW5kYm94TWV0cmljc1JlcXVlc3QiUwodTGlzdFBvZFNhbmRib3hNZXRyaWNzUmVzcG9uc2USMgoLcG9kX21ldHJpY3MYASADKAsyHS5ydW50aW1lLnYxLlBvZFNhbmRib3hNZXRyaWNzIokBChFQb2RTYW5kYm94TWV0cmljcxIWCg5wb2Rfc2FuZGJveF9pZBgBIAEoCRIjCgdtZXRyaWNzGAIgAygLMhIucnVudGltZS52MS5NZXRyaWMSNwoRY29udGFpbmVyX21ldHJpY3MYAyADKAsyHC5ydW50aW1lLnYxLkNvbnRhaW5lck1ldHJpY3MiTQoQQ29udGFpbmVyTWV0cmljcxIUCgxjb250YWluZXJfaWQYASABKAkSIwoHbWV0cmljcxgCIAMoCzISLnJ1bnRpbWUudjEuTWV0cmljIpQBCgZNZXRyaWMSDAoEbmFtZRgBIAEoCRIRCgl0aW1lc3RhbXAYAiABKAMSKwoLbWV0cmljX3R5cGUYAyABKA4yFi5ydW50aW1lLnYxLk1ldHJpY1R5cGUSFAoMbGFiZWxfdmFsdWVzGAQgAygJEiYKBXZhbHVlGAUgASgLMhcucnVudGltZS52MS5VSW50NjRWYWx1ZSIWChRSdW50aW1lQ29uZmlnUmVxdWVzdCJNChVSdW50aW1lQ29uZmlnUmVzcG9uc2USNAoFbGludXgYASABKAsyJS5ydW50aW1lLnYxLkxpbnV4UnVudGltZUNvbmZpZ3VyYXRpb24iTAoZTGludXhSdW50aW1lQ29uZmlndXJhdGlvbhIvCg1jZ3JvdXBfZHJpdmVyGAEgASgOMhgucnVudGltZS52MS5DZ3JvdXBEcml2ZXIiqQEKIFVwZGF0ZVBvZFNhbmRib3hSZXNvdXJjZXNSZXF1ZXN0EhYKDnBvZF9zYW5kYm94X2lkGAEgASgJEjUKCG92ZXJoZWFkGAIgASgLMiMucnVudGltZS52MS5MaW51eENvbnRhaW5lclJlc291cmNlcxI2CglyZXNvdXJjZXMYAyABKAsyIy5ydW50aW1lLnYxLkxpbnV4Q29udGFpbmVyUmVzb3VyY2VzIiMKIVVwZGF0ZVBvZFNhbmRib3hSZXNvdXJjZXNSZXNwb25zZSomCghQcm90b2NvbBIHCgNUQ1AQABIHCgNVRFAQARIICgRTQ1RQEAIqbQoQTW91bnRQcm9wYWdhdGlvbhIXChNQUk9QQUdBVElPTl9QUklWQVRFEAASIQodUFJPUEFHQVRJT05fSE9TVF9UT19DT05UQUlORVIQARIdChlQUk9QQUdBVElPTl9CSURJUkVDVElPTkFMEAIqPQoNTmFtZXNwYWNlTW9kZRIHCgNQT0QQABINCglDT05UQUlORVIQARIICgROT0RFEAISCgoGVEFSR0VUEAMqMQoYU3VwcGxlbWVudGFsR3JvdXBzUG9saWN5EgkKBU1lcmdlEAASCgoGU3RyaWN0EAEqOgoPUG9kU2FuZGJveFN0YXRlEhEKDVNBTkRCT1hfUkVBRFkQABIUChBTQU5EQk9YX05PVFJFQURZEAEqrAgKBlNpZ25hbBITCg9SVU5USU1FX0RFRkFVTFQQABILCgdTSUdBQlJUEAESCwoHU0lHQUxSTRACEgoKBlNJR0JVUxADEgsKB1NJR0NITEQQBBIKCgZTSUdDTEQQBRILCgdTSUdDT05UEAYSCgoGU0lHRlBFEAcSCgoGU0lHSFVQEAgSCgoGU0lHSUxMEAkSCgoGU0lHSU5UEAoSCQoFU0lHSU8QCxIKCgZTSUdJT1QQDBILCgdTSUdLSUxMEA0SCwoHU0lHUElQRRAOEgsKB1NJR1BPTEwQDxILCgdTSUdQUk9GEBASCgoGU0lHUFdSEBESCwoHU0lHUVVJVBASEgsKB1NJR1NFR1YQExINCglTSUdTVEtGTFQQFBILCgdTSUdTVE9QEBUSCgoGU0lHU1lTEBYSCwoHU0lHVEVSTRAXEgsKB1NJR1RSQVAQGBILCgdTSUdUU1RQEBkSCwoHU0lHVFRJThAaEgsKB1NJR1RUT1UQGxIKCgZTSUdVUkcQHBILCgdTSUdVU1IxEB0SCwoHU0lHVVNSMhAeEg0KCVNJR1ZUQUxSTRAfEgwKCFNJR1dJTkNIECASCwoHU0lHWENQVRAhEgsKB1NJR1hGU1oQIhIMCghTSUdSVE1JThAjEhEKDVNJR1JUTUlOUExVUzEQJBIRCg1TSUdSVE1JTlBMVVMyECUSEQoNU0lHUlRNSU5QTFVTMxAmEhEKDVNJR1JUTUlOUExVUzQQJxIRCg1TSUdSVE1JTlBMVVM1ECgSEQoNU0lHUlRNSU5QTFVTNhApEhEKDVNJR1JUTUlOUExVUzcQKhIRCg1TSUdSVE1JTlBMVVM4ECsSEQoNU0lHUlRNSU5QTFVTORAsEhIKDlNJR1JUTUlOUExVUzEwEC0SEgoOU0lHUlRNSU5QTFVTMTEQLhISCg5TSUdSVE1JTlBMVVMxMhAvEhIKDlNJR1JUTUlOUExVUzEzEDASEgoOU0lHUlRNSU5QTFVTMTQQMRISCg5TSUdSVE1JTlBMVVMxNRAyEhMKD1NJR1JUTUFYTUlOVVMxNBAzEhMKD1NJR1JUTUFYTUlOVVMxMxA0EhMKD1NJR1JUTUFYTUlOVVMxMhA1EhMKD1NJR1JUTUFYTUlOVVMxMRA2EhMKD1NJR1JUTUFYTUlOVVMxMBA3EhIKDlNJR1JUTUFYTUlOVVM5EDgSEgoOU0lHUlRNQVhNSU5VUzgQORISCg5TSUdSVE1BWE1JTlVTNxA6EhIKDlNJR1JUTUFYTUlOVVM2EDsSEgoOU0lHUlRNQVhNSU5VUzUQPBISCg5TSUdSVE1BWE1JTlVTNBA9EhIKDlNJR1JUTUFYTUlOVVMzED4SEgoOU0lHUlRNQVhNSU5VUzIQPxISCg5TSUdSVE1BWE1JTlVTMRBAEgwKCFNJR1JUTUFYEEEqawoOQ29udGFpbmVyU3RhdGUSFQoRQ09OVEFJTkVSX0NSRUFURUQQABIVChFDT05UQUlORVJfUlVOTklORxABEhQKEENPTlRBSU5FUl9FWElURUQQAhIVChFDT05UQUlORVJfVU5LTk9XThADKogBChJDb250YWluZXJFdmVudFR5cGUSGwoXQ09OVEFJTkVSX0NSRUFURURfRVZFTlQQABIbChdDT05UQUlORVJfU1RBUlRFRF9FVkVOVBABEhsKF0NPTlRBSU5FUl9TVE9QUEVEX0VWRU5UEAISGwoXQ09OVEFJTkVSX0RFTEVURURfRVZFTlQQAyokCgpNZXRyaWNUeXBlEgsKB0NPVU5URVIQABIJCgVHQVVHRRABKikKDENncm91cERyaXZlchILCgdTWVNURU1EEAASDAoIQ0dST1VQRlMQATL6FQoOUnVudGltZVNlcnZpY2USRAoHVmVyc2lvbhIaLnJ1bnRpbWUudjEuVmVyc2lvblJlcXVlc3QaGy5ydW50aW1lLnYxLlZlcnNpb25SZXNwb25zZSIAElYKDVJ1blBvZFNhbmRib3gSIC5ydW50aW1lLnYxLlJ1blBvZFNhbmRib3hSZXF1ZXN0GiEucnVudGltZS52MS5SdW5Qb2RTYW5kYm94UmVzcG9uc2UiABJZCg5TdG9wUG9kU2FuZGJveBIhLnJ1bnRpbWUudjEuU3RvcFBvZFNhbmRib3hSZXF1ZXN0GiIucnVudGltZS52MS5TdG9wUG9kU2FuZGJveFJlc3BvbnNlIgASXwoQUmVtb3ZlUG9kU2FuZGJveBIjLnJ1bnRpbWUudjEuUmVtb3ZlUG9kU2FuZGJveFJlcXVlc3QaJC5ydW50aW1lLnYxLlJlbW92ZVBvZFNhbmRib3hSZXNwb25zZSIAEl8KEFBvZFNhbmRib3hTdGF0dXMSIy5ydW50aW1lLnYxLlBvZFNhbmRib3hTdGF0dXNSZXF1ZXN0GiQucnVudGltZS52MS5Qb2RTYW5kYm94U3RhdHVzUmVzcG9uc2UiABJZCg5MaXN0UG9kU2FuZGJveBIhLnJ1bnRpbWUudjEuTGlzdFBvZFNhbmRib3hSZXF1ZXN0GiIucnVudGltZS52MS5MaXN0UG9kU2FuZGJveFJlc3BvbnNlIgASXAoPQ3JlYXRlQ29udGFpbmVyEiIucnVudGltZS52MS5DcmVhdGVDb250YWluZXJSZXF1ZXN0GiMucnVudGltZS52MS5DcmVhdGVDb250YWluZXJSZXNwb25zZSIAElkKDlN0YXJ0Q29udGFpbmVyEiEucnVudGltZS52MS5TdGFydENvbnRhaW5lclJlcXVlc3QaIi5ydW50aW1lLnYxLlN0YXJ0Q29udGFpbmVyUmVzcG9uc2UiABJWCg1TdG9wQ29udGFpbmVyEiAucnVudGltZS52MS5TdG9wQ29udGFpbmVyUmVxdWVzdBohLnJ1bnRpbWUudjEuU3RvcENvbnRhaW5lclJlc3BvbnNlIgASXAoPUmVtb3ZlQ29udGFpbmVyEiIucnVudGltZS52MS5SZW1vdmVDb250YWluZXJSZXF1ZXN0GiMucnVudGltZS52MS5SZW1vdmVDb250YWluZXJSZXNwb25zZSIAElkKDkxpc3RDb250YWluZXJzEiEucnVudGltZS52MS5MaXN0Q29udGFpbmVyc1JlcXVlc3QaIi5ydW50aW1lLnYxLkxpc3RDb250YWluZXJzUmVzcG9uc2UiABJcCg9Db250YWluZXJTdGF0dXMSIi5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXR1c1JlcXVlc3QaIy5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXR1c1Jlc3BvbnNlIgASdwoYVXBkYXRlQ29udGFpbmVyUmVzb3VyY2VzEisucnVudGltZS52MS5VcGRhdGVDb250YWluZXJSZXNvdXJjZXNSZXF1ZXN0GiwucnVudGltZS52MS5VcGRhdGVDb250YWluZXJSZXNvdXJjZXNSZXNwb25zZSIAEmUKElJlb3BlbkNvbnRhaW5lckxvZxIlLnJ1bnRpbWUudjEuUmVvcGVuQ29udGFpbmVyTG9nUmVxdWVzdBomLnJ1bnRpbWUudjEuUmVvcGVuQ29udGFpbmVyTG9nUmVzcG9uc2UiABJHCghFeGVjU3luYxIbLnJ1bnRpbWUudjEuRXhlY1N5bmNSZXF1ZXN0GhwucnVudGltZS52MS5FeGVjU3luY1Jlc3BvbnNlIgASOwoERXhlYxIXLnJ1bnRpbWUudjEuRXhlY1JlcXVlc3QaGC5ydW50aW1lLnYxLkV4ZWNSZXNwb25zZSIAEkEKBkF0dGFjaBIZLnJ1bnRpbWUudjEuQXR0YWNoUmVxdWVzdBoaLnJ1bnRpbWUudjEuQXR0YWNoUmVzcG9uc2UiABJQCgtQb3J0Rm9yd2FyZBIeLnJ1bnRpbWUudjEuUG9ydEZvcndhcmRSZXF1ZXN0Gh8ucnVudGltZS52MS5Qb3J0Rm9yd2FyZFJlc3BvbnNlIgASWQoOQ29udGFpbmVyU3RhdHMSIS5ydW50aW1lLnYxLkNvbnRhaW5lclN0YXRzUmVxdWVzdBoiLnJ1bnRpbWUudjEuQ29udGFpbmVyU3RhdHNSZXNwb25zZSIAEmUKEkxpc3RDb250YWluZXJTdGF0cxIlLnJ1bnRpbWUudjEuTGlzdENvbnRhaW5lclN0YXRzUmVxdWVzdBomLnJ1bnRpbWUudjEuTGlzdENvbnRhaW5lclN0YXRzUmVzcG9uc2UiABJcCg9Qb2RTYW5kYm94U3RhdHMSIi5ydW50aW1lLnYxLlBvZFNhbmRib3hTdGF0c1JlcXVlc3QaIy5ydW50aW1lLnYxLlBvZFNhbmRib3hTdGF0c1Jlc3BvbnNlIgASaAoTTGlzdFBvZFNhbmRib3hTdGF0cxImLnJ1bnRpbWUudjEuTGlzdFBvZFNhbmRib3hTdGF0c1JlcXVlc3QaJy5ydW50aW1lLnYxLkxpc3RQb2RTYW5kYm94U3RhdHNSZXNwb25zZSIAEmgKE1VwZGF0ZVJ1bnRpbWVDb25maWcSJi5ydW50aW1lLnYxLlVwZGF0ZVJ1bnRpbWVDb25maWdSZXF1ZXN0GicucnVudGltZS52MS5VcGRhdGVSdW50aW1lQ29uZmlnUmVzcG9uc2UiABJBCgZTdGF0dXMSGS5ydW50aW1lLnYxLlN0YXR1c1JlcXVlc3QaGi5ydW50aW1lLnYxLlN0YXR1c1Jlc3BvbnNlIgASaAoTQ2hlY2twb2ludENvbnRhaW5lchImLnJ1bnRpbWUudjEuQ2hlY2twb2ludENvbnRhaW5lclJlcXVlc3QaJy5ydW50aW1lLnYxLkNoZWNrcG9pbnRDb250YWluZXJSZXNwb25zZSIAEloKEkdldENvbnRhaW5lckV2ZW50cxIcLnJ1bnRpbWUudjEuR2V0RXZlbnRzUmVxdWVzdBoiLnJ1bnRpbWUudjEuQ29udGFpbmVyRXZlbnRSZXNwb25zZSIAMAESbgoVTGlzdE1ldHJpY0Rlc2NyaXB0b3JzEigucnVudGltZS52MS5MaXN0TWV0cmljRGVzY3JpcHRvcnNSZXF1ZXN0GikucnVudGltZS52MS5MaXN0TWV0cmljRGVzY3JpcHRvcnNSZXNwb25zZSIAEm4KFUxpc3RQb2RTYW5kYm94TWV0cmljcxIoLnJ1bnRpbWUudjEuTGlzdFBvZFNhbmRib3hNZXRyaWNzUmVxdWVzdBopLnJ1bnRpbWUudjEuTGlzdFBvZFNhbmRib3hNZXRyaWNzUmVzcG9uc2UiABJWCg1SdW50aW1lQ29uZmlnEiAucnVudGltZS52MS5SdW50aW1lQ29uZmlnUmVxdWVzdBohLnJ1bnRpbWUudjEuUnVudGltZUNvbmZpZ1Jlc3BvbnNlIgASegoZVXBkYXRlUG9kU2FuZGJveFJlc291cmNlcxIsLnJ1bnRpbWUudjEuVXBkYXRlUG9kU2FuZGJveFJlc291cmNlc1JlcXVlc3QaLS5ydW50aW1lLnYxLlVwZGF0ZVBvZFNhbmRib3hSZXNvdXJjZXNSZXNwb25zZSIAMp8DCgxJbWFnZVNlcnZpY2USTQoKTGlzdEltYWdlcxIdLnJ1bnRpbWUudjEuTGlzdEltYWdlc1JlcXVlc3QaHi5ydW50aW1lLnYxLkxpc3RJbWFnZXNSZXNwb25zZSIAElAKC0ltYWdlU3RhdHVzEh4ucnVudGltZS52MS5JbWFnZVN0YXR1c1JlcXVlc3QaHy5ydW50aW1lLnYxLkltYWdlU3RhdHVzUmVzcG9uc2UiABJKCglQdWxsSW1hZ2USHC5ydW50aW1lLnYxLlB1bGxJbWFnZVJlcXVlc3QaHS5ydW50aW1lLnYxLlB1bGxJbWFnZVJlc3BvbnNlIgASUAoLUmVtb3ZlSW1hZ2USHi5ydW50aW1lLnYxLlJlbW92ZUltYWdlUmVxdWVzdBofLnJ1bnRpbWUudjEuUmVtb3ZlSW1hZ2VSZXNwb25zZSIAElAKC0ltYWdlRnNJbmZvEh4ucnVudGltZS52MS5JbWFnZUZzSW5mb1JlcXVlc3QaHy5ydW50aW1lLnYxLkltYWdlRnNJbmZvUmVzcG9uc2UiAEIkWiJrOHMuaW8vY3JpLWFwaS9wa2cvYXBpcy9ydW50aW1lL3YxYgZwcm90bzM");

/**
 * @generated from message runtime.v1.VersionRequest
 */
export type VersionRequest = Message<"runtime.v1.VersionRequest"> & {
  /**
   * Version of the kubelet runtime API.
   *
   * @generated from field: string version = 1;
   */
  version: string;
};

/**
 * Describes the message runtime.v1.VersionRequest.
 * Use `create(VersionRequestSchema)` to create a new message.
 */
export const VersionRequestSchema: GenMessage<VersionRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 0);

/**
 * @generated from message runtime.v1.VersionResponse
 */
export type VersionResponse = Message<"runtime.v1.VersionResponse"> & {
  /**
   * Version of the kubelet runtime API.
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * Name of the container runtime.
   *
   * @generated from field: string runtime_name = 2;
   */
  runtimeName: string;

  /**
   * Version of the container runtime. The string must be
   * semver-compatible.
   *
   * @generated from field: string runtime_version = 3;
   */
  runtimeVersion: string;

  /**
   * API version of the container runtime. The string must be
   * semver-compatible.
   *
   * @generated from field: string runtime_api_version = 4;
   */
  runtimeApiVersion: string;
};

/**
 * Describes the message runtime.v1.VersionResponse.
 * Use `create(VersionResponseSchema)` to create a new message.
 */
export const VersionResponseSchema: GenMessage<VersionResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 1);

/**
 * DNSConfig specifies the DNS servers and search domains of a sandbox.
 *
 * @generated from message runtime.v1.DNSConfig
 */
export type DNSConfig = Message<"runtime.v1.DNSConfig"> & {
  /**
   * List of DNS servers of the cluster.
   *
   * @generated from field: repeated string servers = 1;
   */
  servers: string[];

  /**
   * List of DNS search domains of the cluster.
   *
   * @generated from field: repeated string searches = 2;
   */
  searches: string[];

  /**
   * List of DNS options. See https://linux.die.net/man/5/resolv.conf
   * for all available options.
   *
   * @generated from field: repeated string options = 3;
   */
  options: string[];
};

/**
 * Describes the message runtime.v1.DNSConfig.
 * Use `create(DNSConfigSchema)` to create a new message.
 */
export const DNSConfigSchema: GenMessage<DNSConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 2);

/**
 * PortMapping specifies the port mapping configurations of a sandbox.
 *
 * @generated from message runtime.v1.PortMapping
 */
export type PortMapping = Message<"runtime.v1.PortMapping"> & {
  /**
   * Protocol of the port mapping.
   *
   * @generated from field: runtime.v1.Protocol protocol = 1;
   */
  protocol: Protocol;

  /**
   * Port number within the container. Default: 0 (not specified).
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort: number;

  /**
   * Port number on the host to map the container port to.
   *
   * * Valid host port range is 1-65535.
   * * The value 0 has explicit semantic meaning: it indicates NO host port should be allocated.
   * * The value 0 does NOT indicate dynamic port allocation. Future implementations
   *   of dynamic allocation will use different values/semantics.
   * * Implementations MUST handle the case where this field is explicitly set to 0,
   *   This field SHOULD be omitted when no port is required.
   *
   * Default: If omitted, container port will not be exposed on the host.
   *
   * @generated from field: int32 host_port = 3;
   */
  hostPort: number;

  /**
   * Host IP.
   *
   * @generated from field: string host_ip = 4;
   */
  hostIp: string;
};

/**
 * Describes the message runtime.v1.PortMapping.
 * Use `create(PortMappingSchema)` to create a new message.
 */
export const PortMappingSchema: GenMessage<PortMapping> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 3);

/**
 * Mount specifies a host volume to mount into a container.
 *
 * @generated from message runtime.v1.Mount
 */
export type Mount = Message<"runtime.v1.Mount"> & {
  /**
   * Path of the mount within the container.
   *
   * @generated from field: string container_path = 1;
   */
  containerPath: string;

  /**
   * Path of the mount on the host. Has to be empty if the image field below
   * is provided, because those fields are mutually exclusive. If the image
   * field below is nil and the host path doesn't exist, then runtimes should
   * report an error. If the hostpath is a symbolic link, runtimes should
   * follow the symlink and mount the real destination to container.
   *
   * @generated from field: string host_path = 2;
   */
  hostPath: string;

  /**
   * If set, the mount is read-only.
   *
   * @generated from field: bool readonly = 3;
   */
  readonly: boolean;

  /**
   * If set, the mount needs SELinux relabeling.
   *
   * @generated from field: bool selinux_relabel = 4;
   */
  selinuxRelabel: boolean;

  /**
   * Requested propagation mode.
   *
   * @generated from field: runtime.v1.MountPropagation propagation = 5;
   */
  propagation: MountPropagation;

  /**
   * UidMappings specifies the runtime UID mappings for the mount.
   *
   * @generated from field: repeated runtime.v1.IDMapping uidMappings = 6;
   */
  uidMappings: IDMapping[];

  /**
   * GidMappings specifies the runtime GID mappings for the mount.
   *
   * @generated from field: repeated runtime.v1.IDMapping gidMappings = 7;
   */
  gidMappings: IDMapping[];

  /**
   * If set to true, the mount is made recursive read-only.
   * In this CRI API, recursive_read_only is a plain true/false boolean, although its equivalent
   * in the Kubernetes core API is a quaternary that can be nil, "Enabled", "IfPossible", or "Disabled".
   * kubelet translates that quaternary value in the core API into a boolean in this CRI API.
   * Remarks:
   * - nil is just treated as false
   * - when set to true, readonly must be explicitly set to true, and propagation must be PRIVATE (0).
   * - (readonly == false && recursive_read_only == false) does not make the mount read-only.
   *
   * @generated from field: bool recursive_read_only = 8;
   */
  recursiveReadOnly: boolean;

  /**
   * Mount an image reference (image ID, with or without digest), which is a
   * special use case for image volume mounts. If this field is set, then
   * host_path should be unset. All image mounts are per feature definition
   * readonly (noexec). The kubelet does an PullImage RPC and evaluates the returned
   * PullImageResponse.image_ref value, which is then set to the
   * ImageSpec.image field. Runtimes are expected to mount the image as
   * required.
   * Introduced in the Image Volume Source KEP: https://kep.k8s.io/4639
   *
   * @generated from field: runtime.v1.ImageSpec image = 9;
   */
  image?: ImageSpec;

  /**
   * Specific image sub path to be used from inside the image instead of its
   * root, only necessary if the above image field is set. If the sub path is
   * not empty and does not exist in the image, then runtimes should fail and
   * return an error.
   * Introduced in the Image Volume Source KEP beta graduation: https://kep.k8s.io/4639
   *
   * @generated from field: string image_sub_path = 10;
   */
  imageSubPath: string;
};

/**
 * Describes the message runtime.v1.Mount.
 * Use `create(MountSchema)` to create a new message.
 */
export const MountSchema: GenMessage<Mount> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 4);

/**
 * IDMapping describes host to container ID mappings for a pod sandbox.
 *
 * @generated from message runtime.v1.IDMapping
 */
export type IDMapping = Message<"runtime.v1.IDMapping"> & {
  /**
   * HostId is the id on the host.
   *
   * @generated from field: uint32 host_id = 1;
   */
  hostId: number;

  /**
   * ContainerId is the id in the container.
   *
   * @generated from field: uint32 container_id = 2;
   */
  containerId: number;

  /**
   * Length is the size of the range to map.
   *
   * @generated from field: uint32 length = 3;
   */
  length: number;
};

/**
 * Describes the message runtime.v1.IDMapping.
 * Use `create(IDMappingSchema)` to create a new message.
 */
export const IDMappingSchema: GenMessage<IDMapping> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 5);

/**
 * UserNamespace describes the intended user namespace configuration for a pod sandbox.
 *
 * @generated from message runtime.v1.UserNamespace
 */
export type UserNamespace = Message<"runtime.v1.UserNamespace"> & {
  /**
   * Mode is the NamespaceMode for this UserNamespace.
   * Note: NamespaceMode for UserNamespace currently supports only POD and NODE, not CONTAINER OR TARGET.
   *
   * @generated from field: runtime.v1.NamespaceMode mode = 1;
   */
  mode: NamespaceMode;

  /**
   * Uids specifies the UID mappings for the user namespace.
   *
   * @generated from field: repeated runtime.v1.IDMapping uids = 2;
   */
  uids: IDMapping[];

  /**
   * Gids specifies the GID mappings for the user namespace.
   *
   * @generated from field: repeated runtime.v1.IDMapping gids = 3;
   */
  gids: IDMapping[];
};

/**
 * Describes the message runtime.v1.UserNamespace.
 * Use `create(UserNamespaceSchema)` to create a new message.
 */
export const UserNamespaceSchema: GenMessage<UserNamespace> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 6);

/**
 * NamespaceOption provides options for Linux namespaces.
 *
 * @generated from message runtime.v1.NamespaceOption
 */
export type NamespaceOption = Message<"runtime.v1.NamespaceOption"> & {
  /**
   * Network namespace for this container/sandbox.
   * Note: There is currently no way to set CONTAINER scoped network in the Kubernetes API.
   * Namespaces currently set by the kubelet: POD, NODE
   *
   * @generated from field: runtime.v1.NamespaceMode network = 1;
   */
  network: NamespaceMode;

  /**
   * PID namespace for this container/sandbox.
   * Note: The CRI default is POD, but the v1.PodSpec default is CONTAINER.
   * The kubelet's runtime manager will set this to CONTAINER explicitly for v1 pods.
   * Namespaces currently set by the kubelet: POD, CONTAINER, NODE, TARGET
   *
   * @generated from field: runtime.v1.NamespaceMode pid = 2;
   */
  pid: NamespaceMode;

  /**
   * IPC namespace for this container/sandbox.
   * Note: There is currently no way to set CONTAINER scoped IPC in the Kubernetes API.
   * Namespaces currently set by the kubelet: POD, NODE
   *
   * @generated from field: runtime.v1.NamespaceMode ipc = 3;
   */
  ipc: NamespaceMode;

  /**
   * Target Container ID for NamespaceMode of TARGET. This container must have been
   * previously created in the same pod. It is not possible to specify different targets
   * for each namespace.
   *
   * @generated from field: string target_id = 4;
   */
  targetId: string;

  /**
   * UsernsOptions for this pod sandbox.
   * The Kubelet picks the user namespace configuration to use for the pod sandbox.  The mappings
   * are specified as part of the UserNamespace struct.  If the struct is nil, then the POD mode
   * must be assumed.  This is done for backward compatibility with older Kubelet versions that
   * do not set a user namespace.
   *
   * @generated from field: runtime.v1.UserNamespace userns_options = 5;
   */
  usernsOptions?: UserNamespace;
};

/**
 * Describes the message runtime.v1.NamespaceOption.
 * Use `create(NamespaceOptionSchema)` to create a new message.
 */
export const NamespaceOptionSchema: GenMessage<NamespaceOption> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 7);

/**
 * Int64Value is the wrapper of int64.
 *
 * @generated from message runtime.v1.Int64Value
 */
export type Int64Value = Message<"runtime.v1.Int64Value"> & {
  /**
   * The value.
   *
   * @generated from field: int64 value = 1;
   */
  value: bigint;
};

/**
 * Describes the message runtime.v1.Int64Value.
 * Use `create(Int64ValueSchema)` to create a new message.
 */
export const Int64ValueSchema: GenMessage<Int64Value> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 8);

/**
 * LinuxSandboxSecurityContext holds linux security configuration that will be
 * applied to a sandbox. Note that:
 * 1) It does not apply to containers in the pods.
 * 2) It may not be applicable to a PodSandbox which does not contain any running
 *    process.
 *
 * @generated from message runtime.v1.LinuxSandboxSecurityContext
 */
export type LinuxSandboxSecurityContext = Message<"runtime.v1.LinuxSandboxSecurityContext"> & {
  /**
   * Configurations for the sandbox's namespaces.
   * This will be used only if the PodSandbox uses namespace for isolation.
   *
   * @generated from field: runtime.v1.NamespaceOption namespace_options = 1;
   */
  namespaceOptions?: NamespaceOption;

  /**
   * Optional SELinux context to be applied.
   *
   * @generated from field: runtime.v1.SELinuxOption selinux_options = 2;
   */
  selinuxOptions?: SELinuxOption;

  /**
   * UID to run sandbox processes as, when applicable.
   *
   * @generated from field: runtime.v1.Int64Value run_as_user = 3;
   */
  runAsUser?: Int64Value;

  /**
   * GID to run sandbox processes as, when applicable. run_as_group should only
   * be specified when run_as_user is specified; otherwise, the runtime MUST error.
   *
   * @generated from field: runtime.v1.Int64Value run_as_group = 8;
   */
  runAsGroup?: Int64Value;

  /**
   * If set, the root filesystem of the sandbox is read-only.
   *
   * @generated from field: bool readonly_rootfs = 4;
   */
  readonlyRootfs: boolean;

  /**
   * List of groups applied to the first process run in each container.
   * supplemental_groups_policy can control how groups will be calculated.
   *
   * @generated from field: repeated int64 supplemental_groups = 5;
   */
  supplementalGroups: bigint[];

  /**
   * supplemental_groups_policy defines how supplemental groups of the first 
   * container processes are calculated.
   * Valid values are "Merge" and "Strict".
   * If not specified, "Merge" is used.
   *
   * @generated from field: runtime.v1.SupplementalGroupsPolicy supplemental_groups_policy = 11;
   */
  supplementalGroupsPolicy: SupplementalGroupsPolicy;

  /**
   * Indicates whether the sandbox will be asked to run a privileged
   * container. If a privileged container is to be executed within it, this
   * MUST be true.
   * This allows a sandbox to take additional security precautions if no
   * privileged containers are expected to be run.
   *
   * @generated from field: bool privileged = 6;
   */
  privileged: boolean;

  /**
   * Seccomp profile for the sandbox.
   *
   * @generated from field: runtime.v1.SecurityProfile seccomp = 9;
   */
  seccomp?: SecurityProfile;

  /**
   * AppArmor profile for the sandbox.
   *
   * @generated from field: runtime.v1.SecurityProfile apparmor = 10;
   */
  apparmor?: SecurityProfile;

  /**
   * Seccomp profile for the sandbox, candidate values are:
   * * runtime/default: the default profile for the container runtime
   * * unconfined: unconfined profile, ie, no seccomp sandboxing
   * * localhost/<full-path-to-profile>: the profile installed on the node.
   *   <full-path-to-profile> is the full path of the profile.
   * Default: "", which is identical with unconfined.
   *
   * @generated from field: string seccomp_profile_path = 7 [deprecated = true];
   * @deprecated
   */
  seccompProfilePath: string;
};

/**
 * Describes the message runtime.v1.LinuxSandboxSecurityContext.
 * Use `create(LinuxSandboxSecurityContextSchema)` to create a new message.
 */
export const LinuxSandboxSecurityContextSchema: GenMessage<LinuxSandboxSecurityContext> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 9);

/**
 * A security profile which can be used for sandboxes and containers.
 *
 * @generated from message runtime.v1.SecurityProfile
 */
export type SecurityProfile = Message<"runtime.v1.SecurityProfile"> & {
  /**
   * Indicator which `ProfileType` should be applied.
   *
   * @generated from field: runtime.v1.SecurityProfile.ProfileType profile_type = 1;
   */
  profileType: SecurityProfile_ProfileType;

  /**
   * Indicates that a pre-defined profile on the node should be used.
   * Must only be set if `ProfileType` is `Localhost`.
   * For seccomp, it must be an absolute path to the seccomp profile.
   * For AppArmor, this field is the AppArmor `<profile name>/`
   *
   * @generated from field: string localhost_ref = 2;
   */
  localhostRef: string;
};

/**
 * Describes the message runtime.v1.SecurityProfile.
 * Use `create(SecurityProfileSchema)` to create a new message.
 */
export const SecurityProfileSchema: GenMessage<SecurityProfile> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 10);

/**
 * Available profile types.
 *
 * @generated from enum runtime.v1.SecurityProfile.ProfileType
 */
export enum SecurityProfile_ProfileType {
  /**
   * The container runtime default profile should be used.
   *
   * @generated from enum value: RuntimeDefault = 0;
   */
  RuntimeDefault = 0,

  /**
   * Disable the feature for the sandbox or the container.
   *
   * @generated from enum value: Unconfined = 1;
   */
  Unconfined = 1,

  /**
   * A pre-defined profile on the node should be used.
   *
   * @generated from enum value: Localhost = 2;
   */
  Localhost = 2,
}

/**
 * Describes the enum runtime.v1.SecurityProfile.ProfileType.
 */
export const SecurityProfile_ProfileTypeSchema: GenEnum<SecurityProfile_ProfileType> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 10, 0);

/**
 * LinuxPodSandboxConfig holds platform-specific configurations for Linux
 * host platforms and Linux-based containers.
 *
 * @generated from message runtime.v1.LinuxPodSandboxConfig
 */
export type LinuxPodSandboxConfig = Message<"runtime.v1.LinuxPodSandboxConfig"> & {
  /**
   * Parent cgroup of the PodSandbox.
   * The cgroupfs style syntax will be used, but the container runtime can
   * convert it to systemd semantics if needed.
   *
   * @generated from field: string cgroup_parent = 1;
   */
  cgroupParent: string;

  /**
   * LinuxSandboxSecurityContext holds sandbox security attributes.
   *
   * @generated from field: runtime.v1.LinuxSandboxSecurityContext security_context = 2;
   */
  securityContext?: LinuxSandboxSecurityContext;

  /**
   * Sysctls holds linux sysctls config for the sandbox.
   *
   * @generated from field: map<string, string> sysctls = 3;
   */
  sysctls: { [key: string]: string };

  /**
   * Optional overhead represents the overheads associated with this sandbox
   *
   * @generated from field: runtime.v1.LinuxContainerResources overhead = 4;
   */
  overhead?: LinuxContainerResources;

  /**
   * Optional resources represents the sum of container resources for this sandbox
   *
   * @generated from field: runtime.v1.LinuxContainerResources resources = 5;
   */
  resources?: LinuxContainerResources;
};

/**
 * Describes the message runtime.v1.LinuxPodSandboxConfig.
 * Use `create(LinuxPodSandboxConfigSchema)` to create a new message.
 */
export const LinuxPodSandboxConfigSchema: GenMessage<LinuxPodSandboxConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 11);

/**
 * PodSandboxMetadata holds all necessary information for building the sandbox name.
 * The container runtime is encouraged to expose the metadata associated with the
 * PodSandbox in its user interface for better user experience. For example,
 * the runtime can construct a unique PodSandboxName based on the metadata.
 *
 * @generated from message runtime.v1.PodSandboxMetadata
 */
export type PodSandboxMetadata = Message<"runtime.v1.PodSandboxMetadata"> & {
  /**
   * Pod name of the sandbox. Same as the pod name in the Pod ObjectMeta.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Pod UID of the sandbox. Same as the pod UID in the Pod ObjectMeta.
   *
   * @generated from field: string uid = 2;
   */
  uid: string;

  /**
   * Pod namespace of the sandbox. Same as the pod namespace in the Pod ObjectMeta.
   *
   * @generated from field: string namespace = 3;
   */
  namespace: string;

  /**
   * Attempt number of creating the sandbox. Default: 0.
   *
   * @generated from field: uint32 attempt = 4;
   */
  attempt: number;
};

/**
 * Describes the message runtime.v1.PodSandboxMetadata.
 * Use `create(PodSandboxMetadataSchema)` to create a new message.
 */
export const PodSandboxMetadataSchema: GenMessage<PodSandboxMetadata> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 12);

/**
 * PodSandboxConfig holds all the required and optional fields for creating a
 * sandbox.
 *
 * @generated from message runtime.v1.PodSandboxConfig
 */
export type PodSandboxConfig = Message<"runtime.v1.PodSandboxConfig"> & {
  /**
   * Metadata of the sandbox. This information will uniquely identify the
   * sandbox, and the runtime should leverage this to ensure correct
   * operation. The runtime may also use this information to improve UX, such
   * as by constructing a readable name.
   *
   * @generated from field: runtime.v1.PodSandboxMetadata metadata = 1;
   */
  metadata?: PodSandboxMetadata;

  /**
   * Hostname of the sandbox. Hostname could only be empty when the pod
   * network namespace is NODE.
   *
   * @generated from field: string hostname = 2;
   */
  hostname: string;

  /**
   * Path to the directory on the host in which container log files are
   * stored.
   * By default the log of a container going into the LogDirectory will be
   * hooked up to STDOUT and STDERR. However, the LogDirectory may contain
   * binary log files with structured logging data from the individual
   * containers. For example, the files might be newline separated JSON
   * structured logs, systemd-journald journal files, gRPC trace files, etc.
   * E.g.,
   *     PodSandboxConfig.LogDirectory = `/var/log/pods/<NAMESPACE>_<NAME>_<UID>/`
   *     ContainerConfig.LogPath = `containerName/Instance#.log`
   *
   * @generated from field: string log_directory = 3;
   */
  logDirectory: string;

  /**
   * DNS config for the sandbox.
   *
   * @generated from field: runtime.v1.DNSConfig dns_config = 4;
   */
  dnsConfig?: DNSConfig;

  /**
   * Port mappings for the sandbox.
   *
   * @generated from field: repeated runtime.v1.PortMapping port_mappings = 5;
   */
  portMappings: PortMapping[];

  /**
   * Key-value pairs that may be used to scope and select individual resources.
   *
   * @generated from field: map<string, string> labels = 6;
   */
  labels: { [key: string]: string };

  /**
   * Unstructured key-value map that may be set by the kubelet to store and
   * retrieve arbitrary metadata. This will include any annotations set on a
   * pod through the Kubernetes API.
   *
   * Annotations MUST NOT be altered by the runtime; the annotations stored
   * here MUST be returned in the PodSandboxStatus associated with the pod
   * this PodSandboxConfig creates.
   *
   * In general, in order to preserve a well-defined interface between the
   * kubelet and the container runtime, annotations SHOULD NOT influence
   * runtime behaviour.
   *
   * Annotations can also be useful for runtime authors to experiment with
   * new features that are opaque to the Kubernetes APIs (both user-facing
   * and the CRI). Whenever possible, however, runtime authors SHOULD
   * consider proposing new typed fields for any new features instead.
   *
   * @generated from field: map<string, string> annotations = 7;
   */
  annotations: { [key: string]: string };

  /**
   * Optional configurations specific to Linux hosts.
   *
   * @generated from field: runtime.v1.LinuxPodSandboxConfig linux = 8;
   */
  linux?: LinuxPodSandboxConfig;

  /**
   * Optional configurations specific to Windows hosts.
   *
   * @generated from field: runtime.v1.WindowsPodSandboxConfig windows = 9;
   */
  windows?: WindowsPodSandboxConfig;
};

/**
 * Describes the message runtime.v1.PodSandboxConfig.
 * Use `create(PodSandboxConfigSchema)` to create a new message.
 */
export const PodSandboxConfigSchema: GenMessage<PodSandboxConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 13);

/**
 * @generated from message runtime.v1.RunPodSandboxRequest
 */
export type RunPodSandboxRequest = Message<"runtime.v1.RunPodSandboxRequest"> & {
  /**
   * Configuration for creating a PodSandbox.
   *
   * @generated from field: runtime.v1.PodSandboxConfig config = 1;
   */
  config?: PodSandboxConfig;

  /**
   * Named runtime configuration to use for this PodSandbox.
   * If the runtime handler is unknown, this request should be rejected.  An
   * empty string should select the default handler, equivalent to the
   * behavior before this feature was added.
   * See https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   *
   * @generated from field: string runtime_handler = 2;
   */
  runtimeHandler: string;
};

/**
 * Describes the message runtime.v1.RunPodSandboxRequest.
 * Use `create(RunPodSandboxRequestSchema)` to create a new message.
 */
export const RunPodSandboxRequestSchema: GenMessage<RunPodSandboxRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 14);

/**
 * @generated from message runtime.v1.RunPodSandboxResponse
 */
export type RunPodSandboxResponse = Message<"runtime.v1.RunPodSandboxResponse"> & {
  /**
   * ID of the PodSandbox to run.
   *
   * @generated from field: string pod_sandbox_id = 1;
   */
  podSandboxId: string;
};

/**
 * Describes the message runtime.v1.RunPodSandboxResponse.
 * Use `create(RunPodSandboxResponseSchema)` to create a new message.
 */
export const RunPodSandboxResponseSchema: GenMessage<RunPodSandboxResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 15);

/**
 * @generated from message runtime.v1.StopPodSandboxRequest
 */
export type StopPodSandboxRequest = Message<"runtime.v1.StopPodSandboxRequest"> & {
  /**
   * ID of the PodSandbox to stop.
   *
   * @generated from field: string pod_sandbox_id = 1;
   */
  podSandboxId: string;
};

/**
 * Describes the message runtime.v1.StopPodSandboxRequest.
 * Use `create(StopPodSandboxRequestSchema)` to create a new message.
 */
export const StopPodSandboxRequestSchema: GenMessage<StopPodSandboxRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 16);

/**
 * @generated from message runtime.v1.StopPodSandboxResponse
 */
export type StopPodSandboxResponse = Message<"runtime.v1.StopPodSandboxResponse"> & {
};

/**
 * Describes the message runtime.v1.StopPodSandboxResponse.
 * Use `create(StopPodSandboxResponseSchema)` to create a new message.
 */
export const StopPodSandboxResponseSchema: GenMessage<StopPodSandboxResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 17);

/**
 * @generated from message runtime.v1.RemovePodSandboxRequest
 */
export type RemovePodSandboxRequest = Message<"runtime.v1.RemovePodSandboxRequest"> & {
  /**
   * ID of the PodSandbox to remove.
   *
   * @generated from field: string pod_sandbox_id = 1;
   */
  podSandboxId: string;
};

/**
 * Describes the message runtime.v1.RemovePodSandboxRequest.
 * Use `create(RemovePodSandboxRequestSchema)` to create a new message.
 */
export const RemovePodSandboxRequestSchema: GenMessage<RemovePodSandboxRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 18);

/**
 * @generated from message runtime.v1.RemovePodSandboxResponse
 */
export type RemovePodSandboxResponse = Message<"runtime.v1.RemovePodSandboxResponse"> & {
};

/**
 * Describes the message runtime.v1.RemovePodSandboxResponse.
 * Use `create(RemovePodSandboxResponseSchema)` to create a new message.
 */
export const RemovePodSandboxResponseSchema: GenMessage<RemovePodSandboxResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 19);

/**
 * @generated from message runtime.v1.PodSandboxStatusRequest
 */
export type PodSandboxStatusRequest = Message<"runtime.v1.PodSandboxStatusRequest"> & {
  /**
   * ID of the PodSandbox for which to retrieve status.
   *
   * @generated from field: string pod_sandbox_id = 1;
   */
  podSandboxId: string;

  /**
   * Verbose indicates whether to return extra information about the pod sandbox.
   *
   * @generated from field: bool verbose = 2;
   */
  verbose: boolean;
};

/**
 * Describes the message runtime.v1.PodSandboxStatusRequest.
 * Use `create(PodSandboxStatusRequestSchema)` to create a new message.
 */
export const PodSandboxStatusRequestSchema: GenMessage<PodSandboxStatusRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 20);

/**
 * PodIP represents an ip of a Pod
 *
 * @generated from message runtime.v1.PodIP
 */
export type PodIP = Message<"runtime.v1.PodIP"> & {
  /**
   * an ip is a string representation of an IPv4 or an IPv6
   *
   * @generated from field: string ip = 1;
   */
  ip: string;
};

/**
 * Describes the message runtime.v1.PodIP.
 * Use `create(PodIPSchema)` to create a new message.
 */
export const PodIPSchema: GenMessage<PodIP> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 21);

/**
 * PodSandboxNetworkStatus is the status of the network for a PodSandbox.
 * Currently ignored for pods sharing the host networking namespace.
 *
 * @generated from message runtime.v1.PodSandboxNetworkStatus
 */
export type PodSandboxNetworkStatus = Message<"runtime.v1.PodSandboxNetworkStatus"> & {
  /**
   * IP address of the PodSandbox.
   *
   * @generated from field: string ip = 1;
   */
  ip: string;

  /**
   * list of additional ips (not inclusive of PodSandboxNetworkStatus.Ip) of the PodSandBoxNetworkStatus
   *
   * @generated from field: repeated runtime.v1.PodIP additional_ips = 2;
   */
  additionalIps: PodIP[];
};

/**
 * Describes the message runtime.v1.PodSandboxNetworkStatus.
 * Use `create(PodSandboxNetworkStatusSchema)` to create a new message.
 */
export const PodSandboxNetworkStatusSchema: GenMessage<PodSandboxNetworkStatus> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 22);

/**
 * Namespace contains paths to the namespaces.
 *
 * @generated from message runtime.v1.Namespace
 */
export type Namespace = Message<"runtime.v1.Namespace"> & {
  /**
   * Namespace options for Linux namespaces.
   *
   * @generated from field: runtime.v1.NamespaceOption options = 2;
   */
  options?: NamespaceOption;
};

/**
 * Describes the message runtime.v1.Namespace.
 * Use `create(NamespaceSchema)` to create a new message.
 */
export const NamespaceSchema: GenMessage<Namespace> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 23);

/**
 * LinuxSandboxStatus contains status specific to Linux sandboxes.
 *
 * @generated from message runtime.v1.LinuxPodSandboxStatus
 */
export type LinuxPodSandboxStatus = Message<"runtime.v1.LinuxPodSandboxStatus"> & {
  /**
   * Paths to the sandbox's namespaces.
   *
   * @generated from field: runtime.v1.Namespace namespaces = 1;
   */
  namespaces?: Namespace;
};

/**
 * Describes the message runtime.v1.LinuxPodSandboxStatus.
 * Use `create(LinuxPodSandboxStatusSchema)` to create a new message.
 */
export const LinuxPodSandboxStatusSchema: GenMessage<LinuxPodSandboxStatus> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 24);

/**
 * PodSandboxStatus contains the status of the PodSandbox.
 *
 * @generated from message runtime.v1.PodSandboxStatus
 */
export type PodSandboxStatus = Message<"runtime.v1.PodSandboxStatus"> & {
  /**
   * ID of the sandbox.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Metadata of the sandbox.
   *
   * @generated from field: runtime.v1.PodSandboxMetadata metadata = 2;
   */
  metadata?: PodSandboxMetadata;

  /**
   * State of the sandbox.
   *
   * @generated from field: runtime.v1.PodSandboxState state = 3;
   */
  state: PodSandboxState;

  /**
   * Creation timestamp of the sandbox in nanoseconds. Must be > 0.
   *
   * @generated from field: int64 created_at = 4;
   */
  createdAt: bigint;

  /**
   * Network contains network status if network is handled by the runtime.
   *
   * @generated from field: runtime.v1.PodSandboxNetworkStatus network = 5;
   */
  network?: PodSandboxNetworkStatus;

  /**
   * Linux-specific status to a pod sandbox.
   *
   * @generated from field: runtime.v1.LinuxPodSandboxStatus linux = 6;
   */
  linux?: LinuxPodSandboxStatus;

  /**
   * Labels are key-value pairs that may be used to scope and select individual resources.
   *
   * @generated from field: map<string, string> labels = 7;
   */
  labels: { [key: string]: string };

  /**
   * Unstructured key-value map holding arbitrary metadata.
   * Annotations MUST NOT be altered by the runtime; the value of this field
   * MUST be identical to that of the corresponding PodSandboxConfig used to
   * instantiate the pod sandbox this status represents.
   *
   * @generated from field: map<string, string> annotations = 8;
   */
  annotations: { [key: string]: string };

  /**
   * runtime configuration used for this PodSandbox.
   *
   * @generated from field: string runtime_handler = 9;
   */
  runtimeHandler: string;
};

/**
 * Describes the message runtime.v1.PodSandboxStatus.
 * Use `create(PodSandboxStatusSchema)` to create a new message.
 */
export const PodSandboxStatusSchema: GenMessage<PodSandboxStatus> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 25);

/**
 * @generated from message runtime.v1.PodSandboxStatusResponse
 */
export type PodSandboxStatusResponse = Message<"runtime.v1.PodSandboxStatusResponse"> & {
  /**
   * Status of the PodSandbox.
   *
   * @generated from field: runtime.v1.PodSandboxStatus status = 1;
   */
  status?: PodSandboxStatus;

  /**
   * Info is extra information of the PodSandbox. The key could be arbitrary string, and
   * value should be in json format. The information could include anything useful for
   * debug, e.g. network namespace for linux container based container runtime.
   * It should only be returned non-empty when Verbose is true.
   *
   * @generated from field: map<string, string> info = 2;
   */
  info: { [key: string]: string };

  /**
   * Container statuses
   *
   * @generated from field: repeated runtime.v1.ContainerStatus containers_statuses = 3;
   */
  containersStatuses: ContainerStatus[];

  /**
   * Timestamp in nanoseconds at which container and pod statuses were recorded
   *
   * @generated from field: int64 timestamp = 4;
   */
  timestamp: bigint;
};

/**
 * Describes the message runtime.v1.PodSandboxStatusResponse.
 * Use `create(PodSandboxStatusResponseSchema)` to create a new message.
 */
export const PodSandboxStatusResponseSchema: GenMessage<PodSandboxStatusResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 26);

/**
 * PodSandboxStateValue is the wrapper of PodSandboxState.
 *
 * @generated from message runtime.v1.PodSandboxStateValue
 */
export type PodSandboxStateValue = Message<"runtime.v1.PodSandboxStateValue"> & {
  /**
   * State of the sandbox.
   *
   * @generated from field: runtime.v1.PodSandboxState state = 1;
   */
  state: PodSandboxState;
};

/**
 * Describes the message runtime.v1.PodSandboxStateValue.
 * Use `create(PodSandboxStateValueSchema)` to create a new message.
 */
export const PodSandboxStateValueSchema: GenMessage<PodSandboxStateValue> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 27);

/**
 * PodSandboxFilter is used to filter a list of PodSandboxes.
 * All those fields are combined with 'AND'
 *
 * @generated from message runtime.v1.PodSandboxFilter
 */
export type PodSandboxFilter = Message<"runtime.v1.PodSandboxFilter"> & {
  /**
   * ID of the sandbox.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * State of the sandbox.
   *
   * @generated from field: runtime.v1.PodSandboxStateValue state = 2;
   */
  state?: PodSandboxStateValue;

  /**
   * LabelSelector to select matches.
   * Only api.MatchLabels is supported for now and the requirements
   * are ANDed. MatchExpressions is not supported yet.
   *
   * @generated from field: map<string, string> label_selector = 3;
   */
  labelSelector: { [key: string]: string };
};

/**
 * Describes the message runtime.v1.PodSandboxFilter.
 * Use `create(PodSandboxFilterSchema)` to create a new message.
 */
export const PodSandboxFilterSchema: GenMessage<PodSandboxFilter> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 28);

/**
 * @generated from message runtime.v1.ListPodSandboxRequest
 */
export type ListPodSandboxRequest = Message<"runtime.v1.ListPodSandboxRequest"> & {
  /**
   * PodSandboxFilter to filter a list of PodSandboxes.
   *
   * @generated from field: runtime.v1.PodSandboxFilter filter = 1;
   */
  filter?: PodSandboxFilter;
};

/**
 * Describes the message runtime.v1.ListPodSandboxRequest.
 * Use `create(ListPodSandboxRequestSchema)` to create a new message.
 */
export const ListPodSandboxRequestSchema: GenMessage<ListPodSandboxRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 29);

/**
 * PodSandbox contains minimal information about a sandbox.
 *
 * @generated from message runtime.v1.PodSandbox
 */
export type PodSandbox = Message<"runtime.v1.PodSandbox"> & {
  /**
   * ID of the PodSandbox.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Metadata of the PodSandbox.
   *
   * @generated from field: runtime.v1.PodSandboxMetadata metadata = 2;
   */
  metadata?: PodSandboxMetadata;

  /**
   * State of the PodSandbox.
   *
   * @generated from field: runtime.v1.PodSandboxState state = 3;
   */
  state: PodSandboxState;

  /**
   * Creation timestamps of the PodSandbox in nanoseconds. Must be > 0.
   *
   * @generated from field: int64 created_at = 4;
   */
  createdAt: bigint;

  /**
   * Labels of the PodSandbox.
   *
   * @generated from field: map<string, string> labels = 5;
   */
  labels: { [key: string]: string };

  /**
   * Unstructured key-value map holding arbitrary metadata.
   * Annotations MUST NOT be altered by the runtime; the value of this field
   * MUST be identical to that of the corresponding PodSandboxConfig used to
   * instantiate this PodSandbox.
   *
   * @generated from field: map<string, string> annotations = 6;
   */
  annotations: { [key: string]: string };

  /**
   * runtime configuration used for this PodSandbox.
   *
   * @generated from field: string runtime_handler = 7;
   */
  runtimeHandler: string;
};

/**
 * Describes the message runtime.v1.PodSandbox.
 * Use `create(PodSandboxSchema)` to create a new message.
 */
export const PodSandboxSchema: GenMessage<PodSandbox> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 30);

/**
 * @generated from message runtime.v1.ListPodSandboxResponse
 */
export type ListPodSandboxResponse = Message<"runtime.v1.ListPodSandboxResponse"> & {
  /**
   * List of PodSandboxes.
   *
   * @generated from field: repeated runtime.v1.PodSandbox items = 1;
   */
  items: PodSandbox[];
};

/**
 * Describes the message runtime.v1.ListPodSandboxResponse.
 * Use `create(ListPodSandboxResponseSchema)` to create a new message.
 */
export const ListPodSandboxResponseSchema: GenMessage<ListPodSandboxResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 31);

/**
 * @generated from message runtime.v1.PodSandboxStatsRequest
 */
export type PodSandboxStatsRequest = Message<"runtime.v1.PodSandboxStatsRequest"> & {
  /**
   * ID of the pod sandbox for which to retrieve stats.
   *
   * @generated from field: string pod_sandbox_id = 1;
   */
  podSandboxId: string;
};

/**
 * Describes the message runtime.v1.PodSandboxStatsRequest.
 * Use `create(PodSandboxStatsRequestSchema)` to create a new message.
 */
export const PodSandboxStatsRequestSchema: GenMessage<PodSandboxStatsRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 32);

/**
 * @generated from message runtime.v1.PodSandboxStatsResponse
 */
export type PodSandboxStatsResponse = Message<"runtime.v1.PodSandboxStatsResponse"> & {
  /**
   * @generated from field: runtime.v1.PodSandboxStats stats = 1;
   */
  stats?: PodSandboxStats;
};

/**
 * Describes the message runtime.v1.PodSandboxStatsResponse.
 * Use `create(PodSandboxStatsResponseSchema)` to create a new message.
 */
export const PodSandboxStatsResponseSchema: GenMessage<PodSandboxStatsResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 33);

/**
 * PodSandboxStatsFilter is used to filter the list of pod sandboxes to retrieve stats for.
 * All those fields are combined with 'AND'.
 *
 * @generated from message runtime.v1.PodSandboxStatsFilter
 */
export type PodSandboxStatsFilter = Message<"runtime.v1.PodSandboxStatsFilter"> & {
  /**
   * ID of the pod sandbox.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * LabelSelector to select matches.
   * Only api.MatchLabels is supported for now and the requirements
   * are ANDed. MatchExpressions is not supported yet.
   *
   * @generated from field: map<string, string> label_selector = 2;
   */
  labelSelector: { [key: string]: string };
};

/**
 * Describes the message runtime.v1.PodSandboxStatsFilter.
 * Use `create(PodSandboxStatsFilterSchema)` to create a new message.
 */
export const PodSandboxStatsFilterSchema: GenMessage<PodSandboxStatsFilter> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 34);

/**
 * @generated from message runtime.v1.ListPodSandboxStatsRequest
 */
export type ListPodSandboxStatsRequest = Message<"runtime.v1.ListPodSandboxStatsRequest"> & {
  /**
   * Filter for the list request.
   *
   * @generated from field: runtime.v1.PodSandboxStatsFilter filter = 1;
   */
  filter?: PodSandboxStatsFilter;
};

/**
 * Describes the message runtime.v1.ListPodSandboxStatsRequest.
 * Use `create(ListPodSandboxStatsRequestSchema)` to create a new message.
 */
export const ListPodSandboxStatsRequestSchema: GenMessage<ListPodSandboxStatsRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 35);

/**
 * @generated from message runtime.v1.ListPodSandboxStatsResponse
 */
export type ListPodSandboxStatsResponse = Message<"runtime.v1.ListPodSandboxStatsResponse"> & {
  /**
   * Stats of the pod sandbox.
   *
   * @generated from field: repeated runtime.v1.PodSandboxStats stats = 1;
   */
  stats: PodSandboxStats[];
};

/**
 * Describes the message runtime.v1.ListPodSandboxStatsResponse.
 * Use `create(ListPodSandboxStatsResponseSchema)` to create a new message.
 */
export const ListPodSandboxStatsResponseSchema: GenMessage<ListPodSandboxStatsResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 36);

/**
 * PodSandboxAttributes provides basic information of the pod sandbox.
 *
 * @generated from message runtime.v1.PodSandboxAttributes
 */
export type PodSandboxAttributes = Message<"runtime.v1.PodSandboxAttributes"> & {
  /**
   * ID of the pod sandbox.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Metadata of the pod sandbox.
   *
   * @generated from field: runtime.v1.PodSandboxMetadata metadata = 2;
   */
  metadata?: PodSandboxMetadata;

  /**
   * Key-value pairs that may be used to scope and select individual resources.
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };

  /**
   * Unstructured key-value map holding arbitrary metadata.
   * Annotations MUST NOT be altered by the runtime; the value of this field
   * MUST be identical to that of the corresponding PodSandboxStatus used to
   * instantiate the PodSandbox this status represents.
   *
   * @generated from field: map<string, string> annotations = 4;
   */
  annotations: { [key: string]: string };
};

/**
 * Describes the message runtime.v1.PodSandboxAttributes.
 * Use `create(PodSandboxAttributesSchema)` to create a new message.
 */
export const PodSandboxAttributesSchema: GenMessage<PodSandboxAttributes> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 37);

/**
 * PodSandboxStats provides the resource usage statistics for a pod.
 * The linux or windows field will be populated depending on the platform.
 *
 * @generated from message runtime.v1.PodSandboxStats
 */
export type PodSandboxStats = Message<"runtime.v1.PodSandboxStats"> & {
  /**
   * Information of the pod.
   *
   * @generated from field: runtime.v1.PodSandboxAttributes attributes = 1;
   */
  attributes?: PodSandboxAttributes;

  /**
   * Stats from linux.
   *
   * @generated from field: runtime.v1.LinuxPodSandboxStats linux = 2;
   */
  linux?: LinuxPodSandboxStats;

  /**
   * Stats from windows.
   *
   * @generated from field: runtime.v1.WindowsPodSandboxStats windows = 3;
   */
  windows?: WindowsPodSandboxStats;
};

/**
 * Describes the message runtime.v1.PodSandboxStats.
 * Use `create(PodSandboxStatsSchema)` to create a new message.
 */
export const PodSandboxStatsSchema: GenMessage<PodSandboxStats> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 38);

/**
 * LinuxPodSandboxStats provides the resource usage statistics for a pod sandbox on linux.
 *
 * @generated from message runtime.v1.LinuxPodSandboxStats
 */
export type LinuxPodSandboxStats = Message<"runtime.v1.LinuxPodSandboxStats"> & {
  /**
   * CPU usage gathered for the pod sandbox.
   *
   * @generated from field: runtime.v1.CpuUsage cpu = 1;
   */
  cpu?: CpuUsage;

  /**
   * Memory usage gathered for the pod sandbox.
   *
   * @generated from field: runtime.v1.MemoryUsage memory = 2;
   */
  memory?: MemoryUsage;

  /**
   * Network usage gathered for the pod sandbox
   *
   * @generated from field: runtime.v1.NetworkUsage network = 3;
   */
  network?: NetworkUsage;

  /**
   * Stats pertaining to processes in the pod sandbox.
   *
   * @generated from field: runtime.v1.ProcessUsage process = 4;
   */
  process?: ProcessUsage;

  /**
   * Stats of containers in the measured pod sandbox.
   *
   * @generated from field: repeated runtime.v1.ContainerStats containers = 5;
   */
  containers: ContainerStats[];

  /**
   * IO usage gathered for the pod sandbox.
   *
   * @generated from field: runtime.v1.IoUsage io = 6;
   */
  io?: IoUsage;
};

/**
 * Describes the message runtime.v1.LinuxPodSandboxStats.
 * Use `create(LinuxPodSandboxStatsSchema)` to create a new message.
 */
export const LinuxPodSandboxStatsSchema: GenMessage<LinuxPodSandboxStats> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 39);

/**
 * WindowsPodSandboxStats provides the resource usage statistics for a pod sandbox on windows
 *
 * @generated from message runtime.v1.WindowsPodSandboxStats
 */
export type WindowsPodSandboxStats = Message<"runtime.v1.WindowsPodSandboxStats"> & {
  /**
   * CPU usage gathered for the pod sandbox.
   *
   * @generated from field: runtime.v1.WindowsCpuUsage cpu = 1;
   */
  cpu?: WindowsCpuUsage;

  /**
   * Memory usage gathered for the pod sandbox.
   *
   * @generated from field: runtime.v1.WindowsMemoryUsage memory = 2;
   */
  memory?: WindowsMemoryUsage;

  /**
   * Network usage gathered for the pod sandbox
   *
   * @generated from field: runtime.v1.WindowsNetworkUsage network = 3;
   */
  network?: WindowsNetworkUsage;

  /**
   * Stats pertaining to processes in the pod sandbox.
   *
   * @generated from field: runtime.v1.WindowsProcessUsage process = 4;
   */
  process?: WindowsProcessUsage;

  /**
   * Stats of containers in the measured pod sandbox.
   *
   * @generated from field: repeated runtime.v1.WindowsContainerStats containers = 5;
   */
  containers: WindowsContainerStats[];
};

/**
 * Describes the message runtime.v1.WindowsPodSandboxStats.
 * Use `create(WindowsPodSandboxStatsSchema)` to create a new message.
 */
export const WindowsPodSandboxStatsSchema: GenMessage<WindowsPodSandboxStats> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 40);

/**
 * NetworkUsage contains data about network resources.
 *
 * @generated from message runtime.v1.NetworkUsage
 */
export type NetworkUsage = Message<"runtime.v1.NetworkUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * Stats for the default network interface.
   *
   * @generated from field: runtime.v1.NetworkInterfaceUsage default_interface = 2;
   */
  defaultInterface?: NetworkInterfaceUsage;

  /**
   * Stats for all found network interfaces, excluding the default.
   *
   * @generated from field: repeated runtime.v1.NetworkInterfaceUsage interfaces = 3;
   */
  interfaces: NetworkInterfaceUsage[];
};

/**
 * Describes the message runtime.v1.NetworkUsage.
 * Use `create(NetworkUsageSchema)` to create a new message.
 */
export const NetworkUsageSchema: GenMessage<NetworkUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 41);

/**
 * WindowsNetworkUsage contains data about network resources specific to Windows.
 *
 * @generated from message runtime.v1.WindowsNetworkUsage
 */
export type WindowsNetworkUsage = Message<"runtime.v1.WindowsNetworkUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * Stats for the default network interface.
   *
   * @generated from field: runtime.v1.WindowsNetworkInterfaceUsage default_interface = 2;
   */
  defaultInterface?: WindowsNetworkInterfaceUsage;

  /**
   * Stats for all found network interfaces, excluding the default.
   *
   * @generated from field: repeated runtime.v1.WindowsNetworkInterfaceUsage interfaces = 3;
   */
  interfaces: WindowsNetworkInterfaceUsage[];
};

/**
 * Describes the message runtime.v1.WindowsNetworkUsage.
 * Use `create(WindowsNetworkUsageSchema)` to create a new message.
 */
export const WindowsNetworkUsageSchema: GenMessage<WindowsNetworkUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 42);

/**
 * NetworkInterfaceUsage contains resource value data about a network interface.
 *
 * @generated from message runtime.v1.NetworkInterfaceUsage
 */
export type NetworkInterfaceUsage = Message<"runtime.v1.NetworkInterfaceUsage"> & {
  /**
   * The name of the network interface.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Cumulative count of bytes received.
   *
   * @generated from field: runtime.v1.UInt64Value rx_bytes = 2;
   */
  rxBytes?: UInt64Value;

  /**
   * Cumulative count of receive errors encountered.
   *
   * @generated from field: runtime.v1.UInt64Value rx_errors = 3;
   */
  rxErrors?: UInt64Value;

  /**
   * Cumulative count of bytes transmitted.
   *
   * @generated from field: runtime.v1.UInt64Value tx_bytes = 4;
   */
  txBytes?: UInt64Value;

  /**
   * Cumulative count of transmit errors encountered.
   *
   * @generated from field: runtime.v1.UInt64Value tx_errors = 5;
   */
  txErrors?: UInt64Value;
};

/**
 * Describes the message runtime.v1.NetworkInterfaceUsage.
 * Use `create(NetworkInterfaceUsageSchema)` to create a new message.
 */
export const NetworkInterfaceUsageSchema: GenMessage<NetworkInterfaceUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 43);

/**
 * WindowsNetworkInterfaceUsage contains resource value data about a network interface specific for Windows.
 *
 * @generated from message runtime.v1.WindowsNetworkInterfaceUsage
 */
export type WindowsNetworkInterfaceUsage = Message<"runtime.v1.WindowsNetworkInterfaceUsage"> & {
  /**
   * The name of the network interface.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Cumulative count of bytes received.
   *
   * @generated from field: runtime.v1.UInt64Value rx_bytes = 2;
   */
  rxBytes?: UInt64Value;

  /**
   * Cumulative count of receive errors encountered.
   *
   * @generated from field: runtime.v1.UInt64Value rx_packets_dropped = 3;
   */
  rxPacketsDropped?: UInt64Value;

  /**
   * Cumulative count of bytes transmitted.
   *
   * @generated from field: runtime.v1.UInt64Value tx_bytes = 4;
   */
  txBytes?: UInt64Value;

  /**
   * Cumulative count of transmit errors encountered.
   *
   * @generated from field: runtime.v1.UInt64Value tx_packets_dropped = 5;
   */
  txPacketsDropped?: UInt64Value;
};

/**
 * Describes the message runtime.v1.WindowsNetworkInterfaceUsage.
 * Use `create(WindowsNetworkInterfaceUsageSchema)` to create a new message.
 */
export const WindowsNetworkInterfaceUsageSchema: GenMessage<WindowsNetworkInterfaceUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 44);

/**
 * ProcessUsage are stats pertaining to processes.
 *
 * @generated from message runtime.v1.ProcessUsage
 */
export type ProcessUsage = Message<"runtime.v1.ProcessUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * Number of processes.
   *
   * @generated from field: runtime.v1.UInt64Value process_count = 2;
   */
  processCount?: UInt64Value;
};

/**
 * Describes the message runtime.v1.ProcessUsage.
 * Use `create(ProcessUsageSchema)` to create a new message.
 */
export const ProcessUsageSchema: GenMessage<ProcessUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 45);

/**
 * WindowsProcessUsage are stats pertaining to processes specific to Windows.
 *
 * @generated from message runtime.v1.WindowsProcessUsage
 */
export type WindowsProcessUsage = Message<"runtime.v1.WindowsProcessUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * Number of processes.
   *
   * @generated from field: runtime.v1.UInt64Value process_count = 2;
   */
  processCount?: UInt64Value;
};

/**
 * Describes the message runtime.v1.WindowsProcessUsage.
 * Use `create(WindowsProcessUsageSchema)` to create a new message.
 */
export const WindowsProcessUsageSchema: GenMessage<WindowsProcessUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 46);

/**
 * ImageSpec is an internal representation of an image.
 *
 * @generated from message runtime.v1.ImageSpec
 */
export type ImageSpec = Message<"runtime.v1.ImageSpec"> & {
  /**
   * Container's Image field (e.g. imageID or imageDigest).
   *
   * @generated from field: string image = 1;
   */
  image: string;

  /**
   * Unstructured key-value map holding arbitrary metadata.
   * ImageSpec Annotations can be used to help the runtime target specific
   * images in multi-arch images.
   *
   * @generated from field: map<string, string> annotations = 2;
   */
  annotations: { [key: string]: string };

  /**
   * The container image reference specified by the user (e.g. image[:tag] or digest).
   * Only set if available within the RPC context.
   *
   * @generated from field: string user_specified_image = 18;
   */
  userSpecifiedImage: string;

  /**
   * Runtime handler to use for pulling the image.
   * If the runtime handler is unknown, the request should be rejected.
   * An empty string would select the default runtime handler.
   *
   * @generated from field: string runtime_handler = 19;
   */
  runtimeHandler: string;
};

/**
 * Describes the message runtime.v1.ImageSpec.
 * Use `create(ImageSpecSchema)` to create a new message.
 */
export const ImageSpecSchema: GenMessage<ImageSpec> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 47);

/**
 * @generated from message runtime.v1.KeyValue
 */
export type KeyValue = Message<"runtime.v1.KeyValue"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: string value = 2;
   */
  value: string;
};

/**
 * Describes the message runtime.v1.KeyValue.
 * Use `create(KeyValueSchema)` to create a new message.
 */
export const KeyValueSchema: GenMessage<KeyValue> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 48);

/**
 * LinuxContainerResources specifies Linux specific configuration for
 * resources.
 *
 * @generated from message runtime.v1.LinuxContainerResources
 */
export type LinuxContainerResources = Message<"runtime.v1.LinuxContainerResources"> & {
  /**
   * CPU CFS (Completely Fair Scheduler) period. Default: 0 (not specified).
   *
   * @generated from field: int64 cpu_period = 1;
   */
  cpuPeriod: bigint;

  /**
   * CPU CFS (Completely Fair Scheduler) quota. Default: 0 (not specified).
   *
   * @generated from field: int64 cpu_quota = 2;
   */
  cpuQuota: bigint;

  /**
   * CPU shares (relative weight vs. other containers). Default: 0 (not specified).
   *
   * @generated from field: int64 cpu_shares = 3;
   */
  cpuShares: bigint;

  /**
   * Memory limit in bytes. Default: 0 (not specified).
   *
   * @generated from field: int64 memory_limit_in_bytes = 4;
   */
  memoryLimitInBytes: bigint;

  /**
   * OOMScoreAdj adjusts the oom-killer score. Default: 0 (not specified).
   *
   * @generated from field: int64 oom_score_adj = 5;
   */
  oomScoreAdj: bigint;

  /**
   * CpusetCpus constrains the allowed set of logical CPUs. Default: "" (not specified).
   *
   * @generated from field: string cpuset_cpus = 6;
   */
  cpusetCpus: string;

  /**
   * CpusetMems constrains the allowed set of memory nodes. Default: "" (not specified).
   *
   * @generated from field: string cpuset_mems = 7;
   */
  cpusetMems: string;

  /**
   * List of HugepageLimits to limit the HugeTLB usage of container per page size. Default: nil (not specified).
   *
   * @generated from field: repeated runtime.v1.HugepageLimit hugepage_limits = 8;
   */
  hugepageLimits: HugepageLimit[];

  /**
   * Unified resources for cgroup v2. Default: nil (not specified).
   * Each key/value in the map refers to the cgroup v2.
   * e.g. "memory.max": "6937202688" or "io.weight": "default 100".
   *
   * @generated from field: map<string, string> unified = 9;
   */
  unified: { [key: string]: string };

  /**
   * Memory swap limit in bytes. Default 0 (not specified).
   *
   * @generated from field: int64 memory_swap_limit_in_bytes = 10;
   */
  memorySwapLimitInBytes: bigint;
};

/**
 * Describes the message runtime.v1.LinuxContainerResources.
 * Use `create(LinuxContainerResourcesSchema)` to create a new message.
 */
export const LinuxContainerResourcesSchema: GenMessage<LinuxContainerResources> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 49);

/**
 * HugepageLimit corresponds to the file`hugetlb.<hugepagesize>.limit_in_byte` in container level cgroup.
 * For example, `PageSize=1GB`, `Limit=1073741824` means setting `1073741824` bytes to hugetlb.1GB.limit_in_bytes.
 *
 * @generated from message runtime.v1.HugepageLimit
 */
export type HugepageLimit = Message<"runtime.v1.HugepageLimit"> & {
  /**
   * The value of PageSize has the format <size><unit-prefix>B (2MB, 1GB),
   * and must match the <hugepagesize> of the corresponding control file found in `hugetlb.<hugepagesize>.limit_in_bytes`.
   * The values of <unit-prefix> are intended to be parsed using base 1024("1KB" = 1024, "1MB" = 1048576, etc).
   *
   * @generated from field: string page_size = 1;
   */
  pageSize: string;

  /**
   * limit in bytes of hugepagesize HugeTLB usage.
   *
   * @generated from field: uint64 limit = 2;
   */
  limit: bigint;
};

/**
 * Describes the message runtime.v1.HugepageLimit.
 * Use `create(HugepageLimitSchema)` to create a new message.
 */
export const HugepageLimitSchema: GenMessage<HugepageLimit> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 50);

/**
 * SELinuxOption are the labels to be applied to the container.
 *
 * @generated from message runtime.v1.SELinuxOption
 */
export type SELinuxOption = Message<"runtime.v1.SELinuxOption"> & {
  /**
   * @generated from field: string user = 1;
   */
  user: string;

  /**
   * @generated from field: string role = 2;
   */
  role: string;

  /**
   * @generated from field: string type = 3;
   */
  type: string;

  /**
   * @generated from field: string level = 4;
   */
  level: string;
};

/**
 * Describes the message runtime.v1.SELinuxOption.
 * Use `create(SELinuxOptionSchema)` to create a new message.
 */
export const SELinuxOptionSchema: GenMessage<SELinuxOption> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 51);

/**
 * Capability contains the container capabilities to add or drop
 * Dropping a capability will drop it from all sets.
 * If a capability is added to only the add_capabilities list then it gets added to permitted,
 * inheritable, effective and bounding sets, i.e. all sets except the ambient set.
 * If a capability is added to only the add_ambient_capabilities list then it gets added to all sets, i.e permitted
 * inheritable, effective, bounding and ambient sets.
 * If a capability is added to add_capabilities and add_ambient_capabilities lists then it gets added to all sets, i.e.
 * permitted, inheritable, effective, bounding and ambient sets.
 *
 * @generated from message runtime.v1.Capability
 */
export type Capability = Message<"runtime.v1.Capability"> & {
  /**
   * List of capabilities to add.
   *
   * @generated from field: repeated string add_capabilities = 1;
   */
  addCapabilities: string[];

  /**
   * List of capabilities to drop.
   *
   * @generated from field: repeated string drop_capabilities = 2;
   */
  dropCapabilities: string[];

  /**
   * List of ambient capabilities to add.
   *
   * @generated from field: repeated string add_ambient_capabilities = 3;
   */
  addAmbientCapabilities: string[];
};

/**
 * Describes the message runtime.v1.Capability.
 * Use `create(CapabilitySchema)` to create a new message.
 */
export const CapabilitySchema: GenMessage<Capability> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 52);

/**
 * LinuxContainerSecurityContext holds linux security configuration that will be applied to a container.
 *
 * @generated from message runtime.v1.LinuxContainerSecurityContext
 */
export type LinuxContainerSecurityContext = Message<"runtime.v1.LinuxContainerSecurityContext"> & {
  /**
   * Capabilities to add or drop.
   *
   * @generated from field: runtime.v1.Capability capabilities = 1;
   */
  capabilities?: Capability;

  /**
   * If set, run container in privileged mode.
   * Privileged mode is incompatible with the following options. If
   * privileged is set, the following features MAY have no effect:
   * 1. capabilities
   * 2. selinux_options
   * 4. seccomp
   * 5. apparmor
   *
   * Privileged mode implies the following specific options are applied:
   * 1. All capabilities are added.
   * 2. Sensitive paths, such as kernel module paths within sysfs, are not masked.
   * 3. Any sysfs and procfs mounts are mounted RW.
   * 4. AppArmor confinement is not applied.
   * 5. Seccomp restrictions are not applied.
   * 6. The device cgroup does not restrict access to any devices.
   * 7. All devices from the host's /dev are available within the container.
   * 8. SELinux restrictions are not applied (e.g. label=disabled).
   *
   * @generated from field: bool privileged = 2;
   */
  privileged: boolean;

  /**
   * Configurations for the container's namespaces.
   * Only used if the container uses namespace for isolation.
   *
   * @generated from field: runtime.v1.NamespaceOption namespace_options = 3;
   */
  namespaceOptions?: NamespaceOption;

  /**
   * SELinux context to be optionally applied.
   *
   * @generated from field: runtime.v1.SELinuxOption selinux_options = 4;
   */
  selinuxOptions?: SELinuxOption;

  /**
   * UID to run the container process as. Only one of run_as_user and
   * run_as_username can be specified at a time.
   *
   * @generated from field: runtime.v1.Int64Value run_as_user = 5;
   */
  runAsUser?: Int64Value;

  /**
   * GID to run the container process as. run_as_group should only be specified
   * when run_as_user or run_as_username is specified; otherwise, the runtime
   * MUST error.
   *
   * @generated from field: runtime.v1.Int64Value run_as_group = 12;
   */
  runAsGroup?: Int64Value;

  /**
   * User name to run the container process as. If specified, the user MUST
   * exist in the container image (i.e. in the /etc/passwd inside the image),
   * and be resolved there by the runtime; otherwise, the runtime MUST error.
   *
   * @generated from field: string run_as_username = 6;
   */
  runAsUsername: string;

  /**
   * If set, the root filesystem of the container is read-only.
   *
   * @generated from field: bool readonly_rootfs = 7;
   */
  readonlyRootfs: boolean;

  /**
   * List of groups applied to the first process run in each container.
   * supplemental_groups_policy can control how groups will be calculated.
   *
   * @generated from field: repeated int64 supplemental_groups = 8;
   */
  supplementalGroups: bigint[];

  /**
   * supplemental_groups_policy defines how supplemental groups of the first 
   * container processes are calculated.
   * Valid values are "Merge" and "Strict".
   * If not specified, "Merge" is used.
   *
   * @generated from field: runtime.v1.SupplementalGroupsPolicy supplemental_groups_policy = 17;
   */
  supplementalGroupsPolicy: SupplementalGroupsPolicy;

  /**
   * no_new_privs defines if the flag for no_new_privs should be set on the
   * container.
   *
   * @generated from field: bool no_new_privs = 11;
   */
  noNewPrivs: boolean;

  /**
   * masked_paths is a slice of paths that should be masked by the container
   * runtime, this can be passed directly to the OCI spec.
   *
   * @generated from field: repeated string masked_paths = 13;
   */
  maskedPaths: string[];

  /**
   * readonly_paths is a slice of paths that should be set as readonly by the
   * container runtime, this can be passed directly to the OCI spec.
   *
   * @generated from field: repeated string readonly_paths = 14;
   */
  readonlyPaths: string[];

  /**
   * Seccomp profile for the container.
   *
   * @generated from field: runtime.v1.SecurityProfile seccomp = 15;
   */
  seccomp?: SecurityProfile;

  /**
   * AppArmor profile for the container.
   *
   * @generated from field: runtime.v1.SecurityProfile apparmor = 16;
   */
  apparmor?: SecurityProfile;

  /**
   * AppArmor profile for the container, candidate values are:
   * * runtime/default: equivalent to not specifying a profile.
   * * unconfined: no profiles are loaded
   * * localhost/<profile_name>: profile loaded on the node
   *    (localhost) by name. The possible profile names are detailed at
   *    https://gitlab.com/apparmor/apparmor/-/wikis/AppArmor_Core_Policy_Reference
   *
   * @generated from field: string apparmor_profile = 9 [deprecated = true];
   * @deprecated
   */
  apparmorProfile: string;

  /**
   * Seccomp profile for the container, candidate values are:
   * * runtime/default: the default profile for the container runtime
   * * unconfined: unconfined profile, ie, no seccomp sandboxing
   * * localhost/<full-path-to-profile>: the profile installed on the node.
   *   <full-path-to-profile> is the full path of the profile.
   * Default: "", which is identical with unconfined.
   *
   * @generated from field: string seccomp_profile_path = 10 [deprecated = true];
   * @deprecated
   */
  seccompProfilePath: string;
};

/**
 * Describes the message runtime.v1.LinuxContainerSecurityContext.
 * Use `create(LinuxContainerSecurityContextSchema)` to create a new message.
 */
export const LinuxContainerSecurityContextSchema: GenMessage<LinuxContainerSecurityContext> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 53);

/**
 * LinuxContainerConfig contains platform-specific configuration for
 * Linux-based containers.
 *
 * @generated from message runtime.v1.LinuxContainerConfig
 */
export type LinuxContainerConfig = Message<"runtime.v1.LinuxContainerConfig"> & {
  /**
   * Resources specification for the container.
   *
   * @generated from field: runtime.v1.LinuxContainerResources resources = 1;
   */
  resources?: LinuxContainerResources;

  /**
   * LinuxContainerSecurityContext configuration for the container.
   *
   * @generated from field: runtime.v1.LinuxContainerSecurityContext security_context = 2;
   */
  securityContext?: LinuxContainerSecurityContext;
};

/**
 * Describes the message runtime.v1.LinuxContainerConfig.
 * Use `create(LinuxContainerConfigSchema)` to create a new message.
 */
export const LinuxContainerConfigSchema: GenMessage<LinuxContainerConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 54);

/**
 * @generated from message runtime.v1.LinuxContainerUser
 */
export type LinuxContainerUser = Message<"runtime.v1.LinuxContainerUser"> & {
  /**
   * uid is the primary uid initially attached to the first process in the container
   *
   * @generated from field: int64 uid = 1;
   */
  uid: bigint;

  /**
   * gid is the primary gid initially attached to the first process in the container
   *
   * @generated from field: int64 gid = 2;
   */
  gid: bigint;

  /**
   * supplemental_groups are the supplemental groups initially attached to the first process in the container
   *
   * @generated from field: repeated int64 supplemental_groups = 3;
   */
  supplementalGroups: bigint[];
};

/**
 * Describes the message runtime.v1.LinuxContainerUser.
 * Use `create(LinuxContainerUserSchema)` to create a new message.
 */
export const LinuxContainerUserSchema: GenMessage<LinuxContainerUser> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 55);

/**
 * WindowsNamespaceOption provides options for Windows namespaces.
 *
 * @generated from message runtime.v1.WindowsNamespaceOption
 */
export type WindowsNamespaceOption = Message<"runtime.v1.WindowsNamespaceOption"> & {
  /**
   * Network namespace for this container/sandbox.
   * This is currently never set by the kubelet
   *
   * @generated from field: runtime.v1.NamespaceMode network = 1;
   */
  network: NamespaceMode;
};

/**
 * Describes the message runtime.v1.WindowsNamespaceOption.
 * Use `create(WindowsNamespaceOptionSchema)` to create a new message.
 */
export const WindowsNamespaceOptionSchema: GenMessage<WindowsNamespaceOption> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 56);

/**
 * WindowsSandboxSecurityContext holds platform-specific configurations that will be
 * applied to a sandbox.
 * These settings will only apply to the sandbox container.
 *
 * @generated from message runtime.v1.WindowsSandboxSecurityContext
 */
export type WindowsSandboxSecurityContext = Message<"runtime.v1.WindowsSandboxSecurityContext"> & {
  /**
   * User name to run the container process as. If specified, the user MUST
   * exist in the container image and be resolved there by the runtime;
   * otherwise, the runtime MUST return error.
   *
   * @generated from field: string run_as_username = 1;
   */
  runAsUsername: string;

  /**
   * The contents of the GMSA credential spec to use to run this container.
   *
   * @generated from field: string credential_spec = 2;
   */
  credentialSpec: string;

  /**
   * Indicates whether the container requested to run as a HostProcess container.
   *
   * @generated from field: bool host_process = 3;
   */
  hostProcess: boolean;

  /**
   * Configuration for the sandbox's namespaces
   *
   * @generated from field: runtime.v1.WindowsNamespaceOption namespace_options = 4;
   */
  namespaceOptions?: WindowsNamespaceOption;
};

/**
 * Describes the message runtime.v1.WindowsSandboxSecurityContext.
 * Use `create(WindowsSandboxSecurityContextSchema)` to create a new message.
 */
export const WindowsSandboxSecurityContextSchema: GenMessage<WindowsSandboxSecurityContext> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 57);

/**
 * WindowsPodSandboxConfig holds platform-specific configurations for Windows
 * host platforms and Windows-based containers.
 *
 * @generated from message runtime.v1.WindowsPodSandboxConfig
 */
export type WindowsPodSandboxConfig = Message<"runtime.v1.WindowsPodSandboxConfig"> & {
  /**
   * WindowsSandboxSecurityContext holds sandbox security attributes.
   *
   * @generated from field: runtime.v1.WindowsSandboxSecurityContext security_context = 1;
   */
  securityContext?: WindowsSandboxSecurityContext;
};

/**
 * Describes the message runtime.v1.WindowsPodSandboxConfig.
 * Use `create(WindowsPodSandboxConfigSchema)` to create a new message.
 */
export const WindowsPodSandboxConfigSchema: GenMessage<WindowsPodSandboxConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 58);

/**
 * WindowsContainerSecurityContext holds windows security configuration that will be applied to a container.
 *
 * @generated from message runtime.v1.WindowsContainerSecurityContext
 */
export type WindowsContainerSecurityContext = Message<"runtime.v1.WindowsContainerSecurityContext"> & {
  /**
   * User name to run the container process as. If specified, the user MUST
   * exist in the container image and be resolved there by the runtime;
   * otherwise, the runtime MUST return error.
   *
   * @generated from field: string run_as_username = 1;
   */
  runAsUsername: string;

  /**
   * The contents of the GMSA credential spec to use to run this container.
   *
   * @generated from field: string credential_spec = 2;
   */
  credentialSpec: string;

  /**
   * Indicates whether a container is to be run as a HostProcess container.
   *
   * @generated from field: bool host_process = 3;
   */
  hostProcess: boolean;
};

/**
 * Describes the message runtime.v1.WindowsContainerSecurityContext.
 * Use `create(WindowsContainerSecurityContextSchema)` to create a new message.
 */
export const WindowsContainerSecurityContextSchema: GenMessage<WindowsContainerSecurityContext> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 59);

/**
 * WindowsContainerConfig contains platform-specific configuration for
 * Windows-based containers.
 *
 * @generated from message runtime.v1.WindowsContainerConfig
 */
export type WindowsContainerConfig = Message<"runtime.v1.WindowsContainerConfig"> & {
  /**
   * Resources specification for the container.
   *
   * @generated from field: runtime.v1.WindowsContainerResources resources = 1;
   */
  resources?: WindowsContainerResources;

  /**
   * WindowsContainerSecurityContext configuration for the container.
   *
   * @generated from field: runtime.v1.WindowsContainerSecurityContext security_context = 2;
   */
  securityContext?: WindowsContainerSecurityContext;
};

/**
 * Describes the message runtime.v1.WindowsContainerConfig.
 * Use `create(WindowsContainerConfigSchema)` to create a new message.
 */
export const WindowsContainerConfigSchema: GenMessage<WindowsContainerConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 60);

/**
 * WindowsContainerResources specifies Windows specific configuration for
 * resources.
 *
 * @generated from message runtime.v1.WindowsContainerResources
 */
export type WindowsContainerResources = Message<"runtime.v1.WindowsContainerResources"> & {
  /**
   * CPU shares (relative weight vs. other containers). Default: 0 (not specified).
   *
   * @generated from field: int64 cpu_shares = 1;
   */
  cpuShares: bigint;

  /**
   * Number of CPUs available to the container. Default: 0 (not specified).
   *
   * @generated from field: int64 cpu_count = 2;
   */
  cpuCount: bigint;

  /**
   * Specifies the portion of processor cycles that this container can use as a percentage times 100.
   *
   * @generated from field: int64 cpu_maximum = 3;
   */
  cpuMaximum: bigint;

  /**
   * Memory limit in bytes. Default: 0 (not specified).
   *
   * @generated from field: int64 memory_limit_in_bytes = 4;
   */
  memoryLimitInBytes: bigint;

  /**
   * Specifies the size of the rootfs / scratch space in bytes to be configured for this container. Default: 0 (not specified).
   *
   * @generated from field: int64 rootfs_size_in_bytes = 5;
   */
  rootfsSizeInBytes: bigint;

  /**
   * Optionally specifies the set of CPUs to affinitize for this container.
   *
   * @generated from field: repeated runtime.v1.WindowsCpuGroupAffinity affinity_cpus = 6;
   */
  affinityCpus: WindowsCpuGroupAffinity[];
};

/**
 * Describes the message runtime.v1.WindowsContainerResources.
 * Use `create(WindowsContainerResourcesSchema)` to create a new message.
 */
export const WindowsContainerResourcesSchema: GenMessage<WindowsContainerResources> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 61);

/**
 * WindowsCpuGroupAffinity specifies the CPU mask and group to affinitize.
 * This is similar to the following _GROUP_AFFINITY structure:
 * https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/miniport/ns-miniport-_group_affinity
 *
 * @generated from message runtime.v1.WindowsCpuGroupAffinity
 */
export type WindowsCpuGroupAffinity = Message<"runtime.v1.WindowsCpuGroupAffinity"> & {
  /**
   * CPU mask relative to this CPU group.
   *
   * @generated from field: uint64 cpu_mask = 1;
   */
  cpuMask: bigint;

  /**
   * Processor group the mask refers to, as returned by
   * GetLogicalProcessorInformationEx.
   *
   * @generated from field: uint32 cpu_group = 2;
   */
  cpuGroup: number;
};

/**
 * Describes the message runtime.v1.WindowsCpuGroupAffinity.
 * Use `create(WindowsCpuGroupAffinitySchema)` to create a new message.
 */
export const WindowsCpuGroupAffinitySchema: GenMessage<WindowsCpuGroupAffinity> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 62);

/**
 * ContainerMetadata holds all necessary information for building the container
 * name. The container runtime is encouraged to expose the metadata in its user
 * interface for better user experience. E.g., runtime can construct a unique
 * container name based on the metadata. Note that (name, attempt) is unique
 * within a sandbox for the entire lifetime of the sandbox.
 *
 * @generated from message runtime.v1.ContainerMetadata
 */
export type ContainerMetadata = Message<"runtime.v1.ContainerMetadata"> & {
  /**
   * Name of the container. Same as the container name in the PodSpec.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Attempt number of creating the container. Default: 0.
   *
   * @generated from field: uint32 attempt = 2;
   */
  attempt: number;
};

/**
 * Describes the message runtime.v1.ContainerMetadata.
 * Use `create(ContainerMetadataSchema)` to create a new message.
 */
export const ContainerMetadataSchema: GenMessage<ContainerMetadata> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 63);

/**
 * Device specifies a host device to mount into a container.
 *
 * @generated from message runtime.v1.Device
 */
export type Device = Message<"runtime.v1.Device"> & {
  /**
   * Path of the device within the container.
   *
   * @generated from field: string container_path = 1;
   */
  containerPath: string;

  /**
   * Path of the device on the host.
   *
   * @generated from field: string host_path = 2;
   */
  hostPath: string;

  /**
   * Cgroups permissions of the device, candidates are one or more of
   * * r - allows container to read from the specified device.
   * * w - allows container to write to the specified device.
   * * m - allows container to create device files that do not yet exist.
   *
   * @generated from field: string permissions = 3;
   */
  permissions: string;
};

/**
 * Describes the message runtime.v1.Device.
 * Use `create(DeviceSchema)` to create a new message.
 */
export const DeviceSchema: GenMessage<Device> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 64);

/**
 * CDIDevice specifies a CDI device information.
 *
 * @generated from message runtime.v1.CDIDevice
 */
export type CDIDevice = Message<"runtime.v1.CDIDevice"> & {
  /**
   * Fully qualified CDI device name
   * for example: vendor.com/gpu=gpudevice1
   * see more details in the CDI specification:
   * https://github.com/container-orchestrated-devices/container-device-interface/blob/main/SPEC.md
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message runtime.v1.CDIDevice.
 * Use `create(CDIDeviceSchema)` to create a new message.
 */
export const CDIDeviceSchema: GenMessage<CDIDevice> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 65);

/**
 * ContainerConfig holds all the required and optional fields for creating a
 * container.
 *
 * @generated from message runtime.v1.ContainerConfig
 */
export type ContainerConfig = Message<"runtime.v1.ContainerConfig"> & {
  /**
   * Metadata of the container. This information will uniquely identify the
   * container, and the runtime should leverage this to ensure correct
   * operation. The runtime may also use this information to improve UX, such
   * as by constructing a readable name.
   *
   * @generated from field: runtime.v1.ContainerMetadata metadata = 1;
   */
  metadata?: ContainerMetadata;

  /**
   * Image to use.
   *
   * @generated from field: runtime.v1.ImageSpec image = 2;
   */
  image?: ImageSpec;

  /**
   * Command to execute (i.e., entrypoint for docker)
   *
   * @generated from field: repeated string command = 3;
   */
  command: string[];

  /**
   * Args for the Command (i.e., command for docker)
   *
   * @generated from field: repeated string args = 4;
   */
  args: string[];

  /**
   * Current working directory of the command.
   *
   * @generated from field: string working_dir = 5;
   */
  workingDir: string;

  /**
   * List of environment variable to set in the container.
   *
   * @generated from field: repeated runtime.v1.KeyValue envs = 6;
   */
  envs: KeyValue[];

  /**
   * Mounts for the container.
   *
   * @generated from field: repeated runtime.v1.Mount mounts = 7;
   */
  mounts: Mount[];

  /**
   * Devices for the container.
   *
   * @generated from field: repeated runtime.v1.Device devices = 8;
   */
  devices: Device[];

  /**
   * Key-value pairs that may be used to scope and select individual resources.
   * Label keys are of the form:
   *     label-key ::= prefixed-name | name
   *     prefixed-name ::= prefix '/' name
   *     prefix ::= DNS_SUBDOMAIN
   *     name ::= DNS_LABEL
   *
   * @generated from field: map<string, string> labels = 9;
   */
  labels: { [key: string]: string };

  /**
   * Unstructured key-value map that may be used by the kubelet to store and
   * retrieve arbitrary metadata.
   *
   * Annotations MUST NOT be altered by the runtime; the annotations stored
   * here MUST be returned in the ContainerStatus associated with the container
   * this ContainerConfig creates.
   *
   * In general, in order to preserve a well-defined interface between the
   * kubelet and the container runtime, annotations SHOULD NOT influence
   * runtime behaviour.
   *
   * @generated from field: map<string, string> annotations = 10;
   */
  annotations: { [key: string]: string };

  /**
   * Path relative to PodSandboxConfig.LogDirectory for container to store
   * the log (STDOUT and STDERR) on the host.
   * E.g.,
   *     PodSandboxConfig.LogDirectory = `/var/log/pods/<NAMESPACE>_<NAME>_<UID>/`
   *     ContainerConfig.LogPath = `containerName/Instance#.log`
   *
   * @generated from field: string log_path = 11;
   */
  logPath: string;

  /**
   * Variables for interactive containers, these have very specialized
   * use-cases (e.g. debugging).
   *
   * @generated from field: bool stdin = 12;
   */
  stdin: boolean;

  /**
   * @generated from field: bool stdin_once = 13;
   */
  stdinOnce: boolean;

  /**
   * @generated from field: bool tty = 14;
   */
  tty: boolean;

  /**
   * Configuration specific to Linux containers.
   *
   * @generated from field: runtime.v1.LinuxContainerConfig linux = 15;
   */
  linux?: LinuxContainerConfig;

  /**
   * Configuration specific to Windows containers.
   *
   * @generated from field: runtime.v1.WindowsContainerConfig windows = 16;
   */
  windows?: WindowsContainerConfig;

  /**
   * CDI devices for the container.
   *
   * @generated from field: repeated runtime.v1.CDIDevice CDI_devices = 17;
   */
  CDIDevices: CDIDevice[];

  /**
   * The custom stop signal for the container
   *
   * @generated from field: runtime.v1.Signal stop_signal = 18;
   */
  stopSignal: Signal;
};

/**
 * Describes the message runtime.v1.ContainerConfig.
 * Use `create(ContainerConfigSchema)` to create a new message.
 */
export const ContainerConfigSchema: GenMessage<ContainerConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 66);

/**
 * @generated from message runtime.v1.CreateContainerRequest
 */
export type CreateContainerRequest = Message<"runtime.v1.CreateContainerRequest"> & {
  /**
   * ID of the PodSandbox in which the container should be created.
   *
   * @generated from field: string pod_sandbox_id = 1;
   */
  podSandboxId: string;

  /**
   * Config of the container.
   *
   * @generated from field: runtime.v1.ContainerConfig config = 2;
   */
  config?: ContainerConfig;

  /**
   * Config of the PodSandbox. This is the same config that was passed
   * to RunPodSandboxRequest to create the PodSandbox. It is passed again
   * here just for easy reference. The PodSandboxConfig is immutable and
   * remains the same throughout the lifetime of the pod.
   *
   * @generated from field: runtime.v1.PodSandboxConfig sandbox_config = 3;
   */
  sandboxConfig?: PodSandboxConfig;
};

/**
 * Describes the message runtime.v1.CreateContainerRequest.
 * Use `create(CreateContainerRequestSchema)` to create a new message.
 */
export const CreateContainerRequestSchema: GenMessage<CreateContainerRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 67);

/**
 * @generated from message runtime.v1.CreateContainerResponse
 */
export type CreateContainerResponse = Message<"runtime.v1.CreateContainerResponse"> & {
  /**
   * ID of the created container.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;
};

/**
 * Describes the message runtime.v1.CreateContainerResponse.
 * Use `create(CreateContainerResponseSchema)` to create a new message.
 */
export const CreateContainerResponseSchema: GenMessage<CreateContainerResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 68);

/**
 * @generated from message runtime.v1.StartContainerRequest
 */
export type StartContainerRequest = Message<"runtime.v1.StartContainerRequest"> & {
  /**
   * ID of the container to start.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;
};

/**
 * Describes the message runtime.v1.StartContainerRequest.
 * Use `create(StartContainerRequestSchema)` to create a new message.
 */
export const StartContainerRequestSchema: GenMessage<StartContainerRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 69);

/**
 * @generated from message runtime.v1.StartContainerResponse
 */
export type StartContainerResponse = Message<"runtime.v1.StartContainerResponse"> & {
};

/**
 * Describes the message runtime.v1.StartContainerResponse.
 * Use `create(StartContainerResponseSchema)` to create a new message.
 */
export const StartContainerResponseSchema: GenMessage<StartContainerResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 70);

/**
 * @generated from message runtime.v1.StopContainerRequest
 */
export type StopContainerRequest = Message<"runtime.v1.StopContainerRequest"> & {
  /**
   * ID of the container to stop.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;

  /**
   * Timeout in seconds to wait for the container to stop before forcibly
   * terminating it. Default: 0 (forcibly terminate the container immediately)
   *
   * @generated from field: int64 timeout = 2;
   */
  timeout: bigint;
};

/**
 * Describes the message runtime.v1.StopContainerRequest.
 * Use `create(StopContainerRequestSchema)` to create a new message.
 */
export const StopContainerRequestSchema: GenMessage<StopContainerRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 71);

/**
 * @generated from message runtime.v1.StopContainerResponse
 */
export type StopContainerResponse = Message<"runtime.v1.StopContainerResponse"> & {
};

/**
 * Describes the message runtime.v1.StopContainerResponse.
 * Use `create(StopContainerResponseSchema)` to create a new message.
 */
export const StopContainerResponseSchema: GenMessage<StopContainerResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 72);

/**
 * @generated from message runtime.v1.RemoveContainerRequest
 */
export type RemoveContainerRequest = Message<"runtime.v1.RemoveContainerRequest"> & {
  /**
   * ID of the container to remove.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;
};

/**
 * Describes the message runtime.v1.RemoveContainerRequest.
 * Use `create(RemoveContainerRequestSchema)` to create a new message.
 */
export const RemoveContainerRequestSchema: GenMessage<RemoveContainerRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 73);

/**
 * @generated from message runtime.v1.RemoveContainerResponse
 */
export type RemoveContainerResponse = Message<"runtime.v1.RemoveContainerResponse"> & {
};

/**
 * Describes the message runtime.v1.RemoveContainerResponse.
 * Use `create(RemoveContainerResponseSchema)` to create a new message.
 */
export const RemoveContainerResponseSchema: GenMessage<RemoveContainerResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 74);

/**
 * ContainerStateValue is the wrapper of ContainerState.
 *
 * @generated from message runtime.v1.ContainerStateValue
 */
export type ContainerStateValue = Message<"runtime.v1.ContainerStateValue"> & {
  /**
   * State of the container.
   *
   * @generated from field: runtime.v1.ContainerState state = 1;
   */
  state: ContainerState;
};

/**
 * Describes the message runtime.v1.ContainerStateValue.
 * Use `create(ContainerStateValueSchema)` to create a new message.
 */
export const ContainerStateValueSchema: GenMessage<ContainerStateValue> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 75);

/**
 * ContainerFilter is used to filter containers.
 * All those fields are combined with 'AND'
 *
 * @generated from message runtime.v1.ContainerFilter
 */
export type ContainerFilter = Message<"runtime.v1.ContainerFilter"> & {
  /**
   * ID of the container.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * State of the container.
   *
   * @generated from field: runtime.v1.ContainerStateValue state = 2;
   */
  state?: ContainerStateValue;

  /**
   * ID of the PodSandbox.
   *
   * @generated from field: string pod_sandbox_id = 3;
   */
  podSandboxId: string;

  /**
   * LabelSelector to select matches.
   * Only api.MatchLabels is supported for now and the requirements
   * are ANDed. MatchExpressions is not supported yet.
   *
   * @generated from field: map<string, string> label_selector = 4;
   */
  labelSelector: { [key: string]: string };
};

/**
 * Describes the message runtime.v1.ContainerFilter.
 * Use `create(ContainerFilterSchema)` to create a new message.
 */
export const ContainerFilterSchema: GenMessage<ContainerFilter> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 76);

/**
 * @generated from message runtime.v1.ListContainersRequest
 */
export type ListContainersRequest = Message<"runtime.v1.ListContainersRequest"> & {
  /**
   * @generated from field: runtime.v1.ContainerFilter filter = 1;
   */
  filter?: ContainerFilter;
};

/**
 * Describes the message runtime.v1.ListContainersRequest.
 * Use `create(ListContainersRequestSchema)` to create a new message.
 */
export const ListContainersRequestSchema: GenMessage<ListContainersRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 77);

/**
 * Container provides the runtime information for a container, such as ID, hash,
 * state of the container.
 *
 * @generated from message runtime.v1.Container
 */
export type Container = Message<"runtime.v1.Container"> & {
  /**
   * ID of the container, used by the container runtime to identify
   * a container.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * ID of the sandbox to which this container belongs.
   *
   * @generated from field: string pod_sandbox_id = 2;
   */
  podSandboxId: string;

  /**
   * Metadata of the container.
   *
   * @generated from field: runtime.v1.ContainerMetadata metadata = 3;
   */
  metadata?: ContainerMetadata;

  /**
   * Spec of the image.
   *
   * @generated from field: runtime.v1.ImageSpec image = 4;
   */
  image?: ImageSpec;

  /**
   * Digested reference to the image in use.
   *
   * @generated from field: string image_ref = 5;
   */
  imageRef: string;

  /**
   * State of the container.
   *
   * @generated from field: runtime.v1.ContainerState state = 6;
   */
  state: ContainerState;

  /**
   * Creation time of the container in nanoseconds.
   *
   * @generated from field: int64 created_at = 7;
   */
  createdAt: bigint;

  /**
   * Key-value pairs that may be used to scope and select individual resources.
   *
   * @generated from field: map<string, string> labels = 8;
   */
  labels: { [key: string]: string };

  /**
   * Unstructured key-value map holding arbitrary metadata.
   * Annotations MUST NOT be altered by the runtime; the value of this field
   * MUST be identical to that of the corresponding ContainerConfig used to
   * instantiate this Container.
   *
   * @generated from field: map<string, string> annotations = 9;
   */
  annotations: { [key: string]: string };

  /**
   * Reference to the unique identifier of the image, on the node, as
   * returned in the image service apis.
   *
   * Note: The image_ref above has been historically used by container
   * runtimes to reference images by digest. The image_ref has been also used
   * in the kubelet image garbage collection, which does not work with
   * digests at all. To separate and avoid possible misusage, we now
   * introduce the image_id field, which should always refer to a unique
   * image identifier on the node.
   *
   * @generated from field: string image_id = 10;
   */
  imageId: string;
};

/**
 * Describes the message runtime.v1.Container.
 * Use `create(ContainerSchema)` to create a new message.
 */
export const ContainerSchema: GenMessage<Container> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 78);

/**
 * @generated from message runtime.v1.ListContainersResponse
 */
export type ListContainersResponse = Message<"runtime.v1.ListContainersResponse"> & {
  /**
   * List of containers.
   *
   * @generated from field: repeated runtime.v1.Container containers = 1;
   */
  containers: Container[];
};

/**
 * Describes the message runtime.v1.ListContainersResponse.
 * Use `create(ListContainersResponseSchema)` to create a new message.
 */
export const ListContainersResponseSchema: GenMessage<ListContainersResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 79);

/**
 * @generated from message runtime.v1.ContainerStatusRequest
 */
export type ContainerStatusRequest = Message<"runtime.v1.ContainerStatusRequest"> & {
  /**
   * ID of the container for which to retrieve status.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;

  /**
   * Verbose indicates whether to return extra information about the container.
   *
   * @generated from field: bool verbose = 2;
   */
  verbose: boolean;
};

/**
 * Describes the message runtime.v1.ContainerStatusRequest.
 * Use `create(ContainerStatusRequestSchema)` to create a new message.
 */
export const ContainerStatusRequestSchema: GenMessage<ContainerStatusRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 80);

/**
 * ContainerStatus represents the status of a container.
 *
 * @generated from message runtime.v1.ContainerStatus
 */
export type ContainerStatus = Message<"runtime.v1.ContainerStatus"> & {
  /**
   * ID of the container.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Metadata of the container.
   *
   * @generated from field: runtime.v1.ContainerMetadata metadata = 2;
   */
  metadata?: ContainerMetadata;

  /**
   * Status of the container.
   *
   * @generated from field: runtime.v1.ContainerState state = 3;
   */
  state: ContainerState;

  /**
   * Creation time of the container in nanoseconds.
   *
   * @generated from field: int64 created_at = 4;
   */
  createdAt: bigint;

  /**
   * Start time of the container in nanoseconds. Default: 0 (not specified).
   *
   * @generated from field: int64 started_at = 5;
   */
  startedAt: bigint;

  /**
   * Finish time of the container in nanoseconds. Default: 0 (not specified).
   *
   * @generated from field: int64 finished_at = 6;
   */
  finishedAt: bigint;

  /**
   * Exit code of the container. Only required when finished_at != 0. Default: 0.
   *
   * @generated from field: int32 exit_code = 7;
   */
  exitCode: number;

  /**
   * Spec of the image.
   *
   * @generated from field: runtime.v1.ImageSpec image = 8;
   */
  image?: ImageSpec;

  /**
   * Digested reference to the image in use.
   *
   * @generated from field: string image_ref = 9;
   */
  imageRef: string;

  /**
   * Brief CamelCase string explaining why container is in its current state.
   * Must be set to "OOMKilled" for containers terminated by cgroup-based Out-of-Memory killer.
   *
   * @generated from field: string reason = 10;
   */
  reason: string;

  /**
   * Human-readable message indicating details about why container is in its
   * current state.
   *
   * @generated from field: string message = 11;
   */
  message: string;

  /**
   * Key-value pairs that may be used to scope and select individual resources.
   *
   * @generated from field: map<string, string> labels = 12;
   */
  labels: { [key: string]: string };

  /**
   * Unstructured key-value map holding arbitrary metadata.
   * Annotations MUST NOT be altered by the runtime; the value of this field
   * MUST be identical to that of the corresponding ContainerConfig used to
   * instantiate the Container this status represents.
   *
   * @generated from field: map<string, string> annotations = 13;
   */
  annotations: { [key: string]: string };

  /**
   * Mounts for the container.
   *
   * @generated from field: repeated runtime.v1.Mount mounts = 14;
   */
  mounts: Mount[];

  /**
   * Log path of container.
   *
   * @generated from field: string log_path = 15;
   */
  logPath: string;

  /**
   * Resource limits configuration of the container.
   *
   * @generated from field: runtime.v1.ContainerResources resources = 16;
   */
  resources?: ContainerResources;

  /**
   * Reference to the unique identifier of the image, on the node, as
   * returned in the image service apis.
   *
   * Note: The image_ref above has been historically used by container
   * runtimes to reference images by digest. To separate and avoid possible
   * misusage, we now introduce the image_id field, which should always refer
   * to a unique image identifier on the node.
   *
   * @generated from field: string image_id = 17;
   */
  imageId: string;

  /**
   * User identities initially attached to the container
   *
   * @generated from field: runtime.v1.ContainerUser user = 18;
   */
  user?: ContainerUser;

  /**
   * Returns the stop signal used by the container runtime to terminate the container 
   *
   * @generated from field: runtime.v1.Signal stop_signal = 19;
   */
  stopSignal: Signal;
};

/**
 * Describes the message runtime.v1.ContainerStatus.
 * Use `create(ContainerStatusSchema)` to create a new message.
 */
export const ContainerStatusSchema: GenMessage<ContainerStatus> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 81);

/**
 * @generated from message runtime.v1.ContainerStatusResponse
 */
export type ContainerStatusResponse = Message<"runtime.v1.ContainerStatusResponse"> & {
  /**
   * Status of the container.
   *
   * @generated from field: runtime.v1.ContainerStatus status = 1;
   */
  status?: ContainerStatus;

  /**
   * Info is extra information of the Container. The key could be arbitrary string, and
   * value should be in json format. The information could include anything useful for
   * debug, e.g. pid for linux container based container runtime.
   * It should only be returned non-empty when Verbose is true.
   *
   * @generated from field: map<string, string> info = 2;
   */
  info: { [key: string]: string };
};

/**
 * Describes the message runtime.v1.ContainerStatusResponse.
 * Use `create(ContainerStatusResponseSchema)` to create a new message.
 */
export const ContainerStatusResponseSchema: GenMessage<ContainerStatusResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 82);

/**
 * ContainerResources holds resource limits configuration for a container.
 *
 * @generated from message runtime.v1.ContainerResources
 */
export type ContainerResources = Message<"runtime.v1.ContainerResources"> & {
  /**
   * Resource limits configuration specific to Linux container.
   *
   * @generated from field: runtime.v1.LinuxContainerResources linux = 1;
   */
  linux?: LinuxContainerResources;

  /**
   * Resource limits configuration specific to Windows container.
   *
   * @generated from field: runtime.v1.WindowsContainerResources windows = 2;
   */
  windows?: WindowsContainerResources;
};

/**
 * Describes the message runtime.v1.ContainerResources.
 * Use `create(ContainerResourcesSchema)` to create a new message.
 */
export const ContainerResourcesSchema: GenMessage<ContainerResources> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 83);

/**
 * @generated from message runtime.v1.ContainerUser
 */
export type ContainerUser = Message<"runtime.v1.ContainerUser"> & {
  /**
   * User identities initially attached to first process in the Linux container.
   * Note that the actual running identity can be changed if the process has enough privilege to do so.
   *
   * @generated from field: runtime.v1.LinuxContainerUser linux = 1;
   */
  linux?: LinuxContainerUser;
};

/**
 * Describes the message runtime.v1.ContainerUser.
 * Use `create(ContainerUserSchema)` to create a new message.
 */
export const ContainerUserSchema: GenMessage<ContainerUser> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 84);

/**
 * @generated from message runtime.v1.UpdateContainerResourcesRequest
 */
export type UpdateContainerResourcesRequest = Message<"runtime.v1.UpdateContainerResourcesRequest"> & {
  /**
   * ID of the container to update.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;

  /**
   * Resource configuration specific to Linux containers.
   *
   * @generated from field: runtime.v1.LinuxContainerResources linux = 2;
   */
  linux?: LinuxContainerResources;

  /**
   * Resource configuration specific to Windows containers.
   *
   * @generated from field: runtime.v1.WindowsContainerResources windows = 3;
   */
  windows?: WindowsContainerResources;

  /**
   * Unstructured key-value map holding arbitrary additional information for
   * container resources updating. This can be used for specifying experimental
   * resources to update or other options to use when updating the container.
   *
   * @generated from field: map<string, string> annotations = 4;
   */
  annotations: { [key: string]: string };
};

/**
 * Describes the message runtime.v1.UpdateContainerResourcesRequest.
 * Use `create(UpdateContainerResourcesRequestSchema)` to create a new message.
 */
export const UpdateContainerResourcesRequestSchema: GenMessage<UpdateContainerResourcesRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 85);

/**
 * @generated from message runtime.v1.UpdateContainerResourcesResponse
 */
export type UpdateContainerResourcesResponse = Message<"runtime.v1.UpdateContainerResourcesResponse"> & {
};

/**
 * Describes the message runtime.v1.UpdateContainerResourcesResponse.
 * Use `create(UpdateContainerResourcesResponseSchema)` to create a new message.
 */
export const UpdateContainerResourcesResponseSchema: GenMessage<UpdateContainerResourcesResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 86);

/**
 * @generated from message runtime.v1.ExecSyncRequest
 */
export type ExecSyncRequest = Message<"runtime.v1.ExecSyncRequest"> & {
  /**
   * ID of the container.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;

  /**
   * Command to execute.
   *
   * @generated from field: repeated string cmd = 2;
   */
  cmd: string[];

  /**
   * Timeout in seconds to stop the command. Default: 0 (run forever).
   *
   * @generated from field: int64 timeout = 3;
   */
  timeout: bigint;
};

/**
 * Describes the message runtime.v1.ExecSyncRequest.
 * Use `create(ExecSyncRequestSchema)` to create a new message.
 */
export const ExecSyncRequestSchema: GenMessage<ExecSyncRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 87);

/**
 * @generated from message runtime.v1.ExecSyncResponse
 */
export type ExecSyncResponse = Message<"runtime.v1.ExecSyncResponse"> & {
  /**
   * Captured command stdout output.
   * The runtime should cap the output of this response to 16MB.
   * If the stdout of the command produces more than 16MB, the remaining output
   * should be discarded, and the command should proceed with no error.
   * See CVE-2022-1708 and CVE-2022-31030 for more information.
   *
   * @generated from field: bytes stdout = 1;
   */
  stdout: Uint8Array;

  /**
   * Captured command stderr output.
   * The runtime should cap the output of this response to 16MB.
   * If the stderr of the command produces more than 16MB, the remaining output
   * should be discarded, and the command should proceed with no error.
   * See CVE-2022-1708 and CVE-2022-31030 for more information.
   *
   * @generated from field: bytes stderr = 2;
   */
  stderr: Uint8Array;

  /**
   * Exit code the command finished with. Default: 0 (success).
   *
   * @generated from field: int32 exit_code = 3;
   */
  exitCode: number;
};

/**
 * Describes the message runtime.v1.ExecSyncResponse.
 * Use `create(ExecSyncResponseSchema)` to create a new message.
 */
export const ExecSyncResponseSchema: GenMessage<ExecSyncResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 88);

/**
 * @generated from message runtime.v1.ExecRequest
 */
export type ExecRequest = Message<"runtime.v1.ExecRequest"> & {
  /**
   * ID of the container in which to execute the command.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;

  /**
   * Command to execute.
   *
   * @generated from field: repeated string cmd = 2;
   */
  cmd: string[];

  /**
   * Whether to exec the command in a TTY.
   *
   * @generated from field: bool tty = 3;
   */
  tty: boolean;

  /**
   * Whether to stream stdin.
   * One of `stdin`, `stdout`, and `stderr` MUST be true.
   *
   * @generated from field: bool stdin = 4;
   */
  stdin: boolean;

  /**
   * Whether to stream stdout.
   * One of `stdin`, `stdout`, and `stderr` MUST be true.
   *
   * @generated from field: bool stdout = 5;
   */
  stdout: boolean;

  /**
   * Whether to stream stderr.
   * One of `stdin`, `stdout`, and `stderr` MUST be true.
   * If `tty` is true, `stderr` MUST be false. Multiplexing is not supported
   * in this case. The output of stdout and stderr will be combined to a
   * single stream.
   *
   * @generated from field: bool stderr = 6;
   */
  stderr: boolean;
};

/**
 * Describes the message runtime.v1.ExecRequest.
 * Use `create(ExecRequestSchema)` to create a new message.
 */
export const ExecRequestSchema: GenMessage<ExecRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 89);

/**
 * @generated from message runtime.v1.ExecResponse
 */
export type ExecResponse = Message<"runtime.v1.ExecResponse"> & {
  /**
   * Fully qualified URL of the exec streaming server.
   *
   * @generated from field: string url = 1;
   */
  url: string;
};

/**
 * Describes the message runtime.v1.ExecResponse.
 * Use `create(ExecResponseSchema)` to create a new message.
 */
export const ExecResponseSchema: GenMessage<ExecResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 90);

/**
 * @generated from message runtime.v1.AttachRequest
 */
export type AttachRequest = Message<"runtime.v1.AttachRequest"> & {
  /**
   * ID of the container to which to attach.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;

  /**
   * Whether to stream stdin.
   * One of `stdin`, `stdout`, and `stderr` MUST be true.
   *
   * @generated from field: bool stdin = 2;
   */
  stdin: boolean;

  /**
   * Whether the process being attached is running in a TTY.
   * This must match the TTY setting in the ContainerConfig.
   *
   * @generated from field: bool tty = 3;
   */
  tty: boolean;

  /**
   * Whether to stream stdout.
   * One of `stdin`, `stdout`, and `stderr` MUST be true.
   *
   * @generated from field: bool stdout = 4;
   */
  stdout: boolean;

  /**
   * Whether to stream stderr.
   * One of `stdin`, `stdout`, and `stderr` MUST be true.
   * If `tty` is true, `stderr` MUST be false. Multiplexing is not supported
   * in this case. The output of stdout and stderr will be combined to a
   * single stream.
   *
   * @generated from field: bool stderr = 5;
   */
  stderr: boolean;
};

/**
 * Describes the message runtime.v1.AttachRequest.
 * Use `create(AttachRequestSchema)` to create a new message.
 */
export const AttachRequestSchema: GenMessage<AttachRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 91);

/**
 * @generated from message runtime.v1.AttachResponse
 */
export type AttachResponse = Message<"runtime.v1.AttachResponse"> & {
  /**
   * Fully qualified URL of the attach streaming server.
   *
   * @generated from field: string url = 1;
   */
  url: string;
};

/**
 * Describes the message runtime.v1.AttachResponse.
 * Use `create(AttachResponseSchema)` to create a new message.
 */
export const AttachResponseSchema: GenMessage<AttachResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 92);

/**
 * @generated from message runtime.v1.PortForwardRequest
 */
export type PortForwardRequest = Message<"runtime.v1.PortForwardRequest"> & {
  /**
   * ID of the container to which to forward the port.
   *
   * @generated from field: string pod_sandbox_id = 1;
   */
  podSandboxId: string;

  /**
   * Port to forward.
   *
   * @generated from field: repeated int32 port = 2;
   */
  port: number[];
};

/**
 * Describes the message runtime.v1.PortForwardRequest.
 * Use `create(PortForwardRequestSchema)` to create a new message.
 */
export const PortForwardRequestSchema: GenMessage<PortForwardRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 93);

/**
 * @generated from message runtime.v1.PortForwardResponse
 */
export type PortForwardResponse = Message<"runtime.v1.PortForwardResponse"> & {
  /**
   * Fully qualified URL of the port-forward streaming server.
   *
   * @generated from field: string url = 1;
   */
  url: string;
};

/**
 * Describes the message runtime.v1.PortForwardResponse.
 * Use `create(PortForwardResponseSchema)` to create a new message.
 */
export const PortForwardResponseSchema: GenMessage<PortForwardResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 94);

/**
 * @generated from message runtime.v1.ImageFilter
 */
export type ImageFilter = Message<"runtime.v1.ImageFilter"> & {
  /**
   * Spec of the image.
   *
   * @generated from field: runtime.v1.ImageSpec image = 1;
   */
  image?: ImageSpec;
};

/**
 * Describes the message runtime.v1.ImageFilter.
 * Use `create(ImageFilterSchema)` to create a new message.
 */
export const ImageFilterSchema: GenMessage<ImageFilter> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 95);

/**
 * @generated from message runtime.v1.ListImagesRequest
 */
export type ListImagesRequest = Message<"runtime.v1.ListImagesRequest"> & {
  /**
   * Filter to list images.
   *
   * @generated from field: runtime.v1.ImageFilter filter = 1;
   */
  filter?: ImageFilter;
};

/**
 * Describes the message runtime.v1.ListImagesRequest.
 * Use `create(ListImagesRequestSchema)` to create a new message.
 */
export const ListImagesRequestSchema: GenMessage<ListImagesRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 96);

/**
 * Basic information about a container image.
 *
 * @generated from message runtime.v1.Image
 */
export type Image = Message<"runtime.v1.Image"> & {
  /**
   * ID of the image.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Other names by which this image is known.
   *
   * @generated from field: repeated string repo_tags = 2;
   */
  repoTags: string[];

  /**
   * Digests by which this image is known.
   *
   * @generated from field: repeated string repo_digests = 3;
   */
  repoDigests: string[];

  /**
   * Size of the image in bytes. Must be > 0.
   *
   * @generated from field: uint64 size = 4;
   */
  size: bigint;

  /**
   * UID that will run the command(s). This is used as a default if no user is
   * specified when creating the container. UID and the following user name
   * are mutually exclusive.
   *
   * @generated from field: runtime.v1.Int64Value uid = 5;
   */
  uid?: Int64Value;

  /**
   * User name that will run the command(s). This is used if UID is not set
   * and no user is specified when creating container.
   *
   * @generated from field: string username = 6;
   */
  username: string;

  /**
   * ImageSpec for image which includes annotations
   *
   * @generated from field: runtime.v1.ImageSpec spec = 7;
   */
  spec?: ImageSpec;

  /**
   * Recommendation on whether this image should be exempt from garbage collection.
   * It must only be treated as a recommendation -- the client can still request that the image be deleted,
   * and the runtime must oblige.
   *
   * @generated from field: bool pinned = 8;
   */
  pinned: boolean;
};

/**
 * Describes the message runtime.v1.Image.
 * Use `create(ImageSchema)` to create a new message.
 */
export const ImageSchema: GenMessage<Image> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 97);

/**
 * @generated from message runtime.v1.ListImagesResponse
 */
export type ListImagesResponse = Message<"runtime.v1.ListImagesResponse"> & {
  /**
   * List of images.
   *
   * @generated from field: repeated runtime.v1.Image images = 1;
   */
  images: Image[];
};

/**
 * Describes the message runtime.v1.ListImagesResponse.
 * Use `create(ListImagesResponseSchema)` to create a new message.
 */
export const ListImagesResponseSchema: GenMessage<ListImagesResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 98);

/**
 * @generated from message runtime.v1.ImageStatusRequest
 */
export type ImageStatusRequest = Message<"runtime.v1.ImageStatusRequest"> & {
  /**
   * Spec of the image.
   *
   * @generated from field: runtime.v1.ImageSpec image = 1;
   */
  image?: ImageSpec;

  /**
   * Verbose indicates whether to return extra information about the image.
   *
   * @generated from field: bool verbose = 2;
   */
  verbose: boolean;
};

/**
 * Describes the message runtime.v1.ImageStatusRequest.
 * Use `create(ImageStatusRequestSchema)` to create a new message.
 */
export const ImageStatusRequestSchema: GenMessage<ImageStatusRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 99);

/**
 * @generated from message runtime.v1.ImageStatusResponse
 */
export type ImageStatusResponse = Message<"runtime.v1.ImageStatusResponse"> & {
  /**
   * Status of the image.
   *
   * @generated from field: runtime.v1.Image image = 1;
   */
  image?: Image;

  /**
   * Info is extra information of the Image. The key could be arbitrary string, and
   * value should be in json format. The information could include anything useful
   * for debug, e.g. image config for oci image based container runtime.
   * It should only be returned non-empty when Verbose is true.
   *
   * @generated from field: map<string, string> info = 2;
   */
  info: { [key: string]: string };
};

/**
 * Describes the message runtime.v1.ImageStatusResponse.
 * Use `create(ImageStatusResponseSchema)` to create a new message.
 */
export const ImageStatusResponseSchema: GenMessage<ImageStatusResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 100);

/**
 * AuthConfig contains authorization information for connecting to a registry.
 *
 * @generated from message runtime.v1.AuthConfig
 */
export type AuthConfig = Message<"runtime.v1.AuthConfig"> & {
  /**
   * @generated from field: string username = 1;
   */
  username: string;

  /**
   * @generated from field: string password = 2;
   */
  password: string;

  /**
   * @generated from field: string auth = 3;
   */
  auth: string;

  /**
   * @generated from field: string server_address = 4;
   */
  serverAddress: string;

  /**
   * IdentityToken is used to authenticate the user and get
   * an access token for the registry.
   *
   * @generated from field: string identity_token = 5;
   */
  identityToken: string;

  /**
   * RegistryToken is a bearer token to be sent to a registry
   *
   * @generated from field: string registry_token = 6;
   */
  registryToken: string;
};

/**
 * Describes the message runtime.v1.AuthConfig.
 * Use `create(AuthConfigSchema)` to create a new message.
 */
export const AuthConfigSchema: GenMessage<AuthConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 101);

/**
 * @generated from message runtime.v1.PullImageRequest
 */
export type PullImageRequest = Message<"runtime.v1.PullImageRequest"> & {
  /**
   * Spec of the image.
   *
   * @generated from field: runtime.v1.ImageSpec image = 1;
   */
  image?: ImageSpec;

  /**
   * Authentication configuration for pulling the image.
   *
   * @generated from field: runtime.v1.AuthConfig auth = 2;
   */
  auth?: AuthConfig;

  /**
   * Config of the PodSandbox, which is used to pull image in PodSandbox context.
   *
   * @generated from field: runtime.v1.PodSandboxConfig sandbox_config = 3;
   */
  sandboxConfig?: PodSandboxConfig;
};

/**
 * Describes the message runtime.v1.PullImageRequest.
 * Use `create(PullImageRequestSchema)` to create a new message.
 */
export const PullImageRequestSchema: GenMessage<PullImageRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 102);

/**
 * @generated from message runtime.v1.PullImageResponse
 */
export type PullImageResponse = Message<"runtime.v1.PullImageResponse"> & {
  /**
   * Reference to the image in use. For most runtimes, this should be an
   * image ID or digest.
   *
   * @generated from field: string image_ref = 1;
   */
  imageRef: string;
};

/**
 * Describes the message runtime.v1.PullImageResponse.
 * Use `create(PullImageResponseSchema)` to create a new message.
 */
export const PullImageResponseSchema: GenMessage<PullImageResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 103);

/**
 * @generated from message runtime.v1.RemoveImageRequest
 */
export type RemoveImageRequest = Message<"runtime.v1.RemoveImageRequest"> & {
  /**
   * Spec of the image to remove.
   *
   * @generated from field: runtime.v1.ImageSpec image = 1;
   */
  image?: ImageSpec;
};

/**
 * Describes the message runtime.v1.RemoveImageRequest.
 * Use `create(RemoveImageRequestSchema)` to create a new message.
 */
export const RemoveImageRequestSchema: GenMessage<RemoveImageRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 104);

/**
 * @generated from message runtime.v1.RemoveImageResponse
 */
export type RemoveImageResponse = Message<"runtime.v1.RemoveImageResponse"> & {
};

/**
 * Describes the message runtime.v1.RemoveImageResponse.
 * Use `create(RemoveImageResponseSchema)` to create a new message.
 */
export const RemoveImageResponseSchema: GenMessage<RemoveImageResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 105);

/**
 * @generated from message runtime.v1.NetworkConfig
 */
export type NetworkConfig = Message<"runtime.v1.NetworkConfig"> & {
  /**
   * CIDR to use for pod IP addresses. If the CIDR is empty, runtimes
   * should omit it.
   *
   * @generated from field: string pod_cidr = 1;
   */
  podCidr: string;
};

/**
 * Describes the message runtime.v1.NetworkConfig.
 * Use `create(NetworkConfigSchema)` to create a new message.
 */
export const NetworkConfigSchema: GenMessage<NetworkConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 106);

/**
 * @generated from message runtime.v1.RuntimeConfig
 */
export type RuntimeConfig = Message<"runtime.v1.RuntimeConfig"> & {
  /**
   * @generated from field: runtime.v1.NetworkConfig network_config = 1;
   */
  networkConfig?: NetworkConfig;
};

/**
 * Describes the message runtime.v1.RuntimeConfig.
 * Use `create(RuntimeConfigSchema)` to create a new message.
 */
export const RuntimeConfigSchema: GenMessage<RuntimeConfig> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 107);

/**
 * @generated from message runtime.v1.UpdateRuntimeConfigRequest
 */
export type UpdateRuntimeConfigRequest = Message<"runtime.v1.UpdateRuntimeConfigRequest"> & {
  /**
   * @generated from field: runtime.v1.RuntimeConfig runtime_config = 1;
   */
  runtimeConfig?: RuntimeConfig;
};

/**
 * Describes the message runtime.v1.UpdateRuntimeConfigRequest.
 * Use `create(UpdateRuntimeConfigRequestSchema)` to create a new message.
 */
export const UpdateRuntimeConfigRequestSchema: GenMessage<UpdateRuntimeConfigRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 108);

/**
 * @generated from message runtime.v1.UpdateRuntimeConfigResponse
 */
export type UpdateRuntimeConfigResponse = Message<"runtime.v1.UpdateRuntimeConfigResponse"> & {
};

/**
 * Describes the message runtime.v1.UpdateRuntimeConfigResponse.
 * Use `create(UpdateRuntimeConfigResponseSchema)` to create a new message.
 */
export const UpdateRuntimeConfigResponseSchema: GenMessage<UpdateRuntimeConfigResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 109);

/**
 * RuntimeCondition contains condition information for the runtime.
 * There are 2 kinds of runtime conditions:
 * 1. Required conditions: Conditions are required for kubelet to work
 * properly. If any required condition is unmet, the node will be not ready.
 * The required conditions include:
 *   * RuntimeReady: RuntimeReady means the runtime is up and ready to accept
 *   basic containers e.g. container only needs host network.
 *   * NetworkReady: NetworkReady means the runtime network is up and ready to
 *   accept containers which require container network.
 * 2. Optional conditions: Conditions are informative to the user, but kubelet
 * will not rely on. Since condition type is an arbitrary string, all conditions
 * not required are optional. These conditions will be exposed to users to help
 * them understand the status of the system.
 *
 * @generated from message runtime.v1.RuntimeCondition
 */
export type RuntimeCondition = Message<"runtime.v1.RuntimeCondition"> & {
  /**
   * Type of runtime condition.
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Status of the condition, one of true/false. Default: false.
   *
   * @generated from field: bool status = 2;
   */
  status: boolean;

  /**
   * Brief CamelCase string containing reason for the condition's last transition.
   *
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * Human-readable message indicating details about last transition.
   *
   * @generated from field: string message = 4;
   */
  message: string;
};

/**
 * Describes the message runtime.v1.RuntimeCondition.
 * Use `create(RuntimeConditionSchema)` to create a new message.
 */
export const RuntimeConditionSchema: GenMessage<RuntimeCondition> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 110);

/**
 * RuntimeStatus is information about the current status of the runtime.
 *
 * @generated from message runtime.v1.RuntimeStatus
 */
export type RuntimeStatus = Message<"runtime.v1.RuntimeStatus"> & {
  /**
   * List of current observed runtime conditions.
   *
   * @generated from field: repeated runtime.v1.RuntimeCondition conditions = 1;
   */
  conditions: RuntimeCondition[];
};

/**
 * Describes the message runtime.v1.RuntimeStatus.
 * Use `create(RuntimeStatusSchema)` to create a new message.
 */
export const RuntimeStatusSchema: GenMessage<RuntimeStatus> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 111);

/**
 * @generated from message runtime.v1.StatusRequest
 */
export type StatusRequest = Message<"runtime.v1.StatusRequest"> & {
  /**
   * Verbose indicates whether to return extra information about the runtime.
   *
   * @generated from field: bool verbose = 1;
   */
  verbose: boolean;
};

/**
 * Describes the message runtime.v1.StatusRequest.
 * Use `create(StatusRequestSchema)` to create a new message.
 */
export const StatusRequestSchema: GenMessage<StatusRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 112);

/**
 * RuntimeHandlerFeatures is a set of features implemented by the runtime handler.
 *
 * @generated from message runtime.v1.RuntimeHandlerFeatures
 */
export type RuntimeHandlerFeatures = Message<"runtime.v1.RuntimeHandlerFeatures"> & {
  /**
   * recursive_read_only_mounts is set to true if the runtime handler supports
   * recursive read-only mounts.
   * For runc-compatible runtimes, availability of this feature can be detected by checking whether
   * the Linux kernel version is >= 5.12, and,  `runc features | jq .mountOptions` contains "rro".
   *
   * @generated from field: bool recursive_read_only_mounts = 1;
   */
  recursiveReadOnlyMounts: boolean;

  /**
   * user_namespaces is set to true if the runtime handler supports user namespaces as implemented
   * in Kubernetes. This means support for both, user namespaces and idmap mounts.
   *
   * @generated from field: bool user_namespaces = 2;
   */
  userNamespaces: boolean;
};

/**
 * Describes the message runtime.v1.RuntimeHandlerFeatures.
 * Use `create(RuntimeHandlerFeaturesSchema)` to create a new message.
 */
export const RuntimeHandlerFeaturesSchema: GenMessage<RuntimeHandlerFeatures> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 113);

/**
 * @generated from message runtime.v1.RuntimeHandler
 */
export type RuntimeHandler = Message<"runtime.v1.RuntimeHandler"> & {
  /**
   * Name must be unique in StatusResponse.
   * An empty string denotes the default handler.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Supported features.
   *
   * @generated from field: runtime.v1.RuntimeHandlerFeatures features = 2;
   */
  features?: RuntimeHandlerFeatures;
};

/**
 * Describes the message runtime.v1.RuntimeHandler.
 * Use `create(RuntimeHandlerSchema)` to create a new message.
 */
export const RuntimeHandlerSchema: GenMessage<RuntimeHandler> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 114);

/**
 * RuntimeFeatures describes the set of features implemented by the CRI implementation.
 * The features contained in the RuntimeFeatures should depend only on the cri implementation
 * independent of runtime handlers.
 *
 * @generated from message runtime.v1.RuntimeFeatures
 */
export type RuntimeFeatures = Message<"runtime.v1.RuntimeFeatures"> & {
  /**
   * supplemental_groups_policy is set to true if the runtime supports SupplementalGroupsPolicy and ContainerUser.
   *
   * @generated from field: bool supplemental_groups_policy = 1;
   */
  supplementalGroupsPolicy: boolean;
};

/**
 * Describes the message runtime.v1.RuntimeFeatures.
 * Use `create(RuntimeFeaturesSchema)` to create a new message.
 */
export const RuntimeFeaturesSchema: GenMessage<RuntimeFeatures> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 115);

/**
 * @generated from message runtime.v1.StatusResponse
 */
export type StatusResponse = Message<"runtime.v1.StatusResponse"> & {
  /**
   * Status of the Runtime.
   *
   * @generated from field: runtime.v1.RuntimeStatus status = 1;
   */
  status?: RuntimeStatus;

  /**
   * Info is extra information of the Runtime. The key could be arbitrary string, and
   * value should be in json format. The information could include anything useful for
   * debug, e.g. plugins used by the container runtime.
   * It should only be returned non-empty when Verbose is true.
   *
   * @generated from field: map<string, string> info = 2;
   */
  info: { [key: string]: string };

  /**
   * Runtime handlers.
   *
   * @generated from field: repeated runtime.v1.RuntimeHandler runtime_handlers = 3;
   */
  runtimeHandlers: RuntimeHandler[];

  /**
   * features describes the set of features implemented by the CRI implementation.
   * This field is supposed to propagate to NodeFeatures in Kubernetes API.
   *
   * @generated from field: runtime.v1.RuntimeFeatures features = 4;
   */
  features?: RuntimeFeatures;
};

/**
 * Describes the message runtime.v1.StatusResponse.
 * Use `create(StatusResponseSchema)` to create a new message.
 */
export const StatusResponseSchema: GenMessage<StatusResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 116);

/**
 * @generated from message runtime.v1.ImageFsInfoRequest
 */
export type ImageFsInfoRequest = Message<"runtime.v1.ImageFsInfoRequest"> & {
};

/**
 * Describes the message runtime.v1.ImageFsInfoRequest.
 * Use `create(ImageFsInfoRequestSchema)` to create a new message.
 */
export const ImageFsInfoRequestSchema: GenMessage<ImageFsInfoRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 117);

/**
 * UInt64Value is the wrapper of uint64.
 *
 * @generated from message runtime.v1.UInt64Value
 */
export type UInt64Value = Message<"runtime.v1.UInt64Value"> & {
  /**
   * The value.
   *
   * @generated from field: uint64 value = 1;
   */
  value: bigint;
};

/**
 * Describes the message runtime.v1.UInt64Value.
 * Use `create(UInt64ValueSchema)` to create a new message.
 */
export const UInt64ValueSchema: GenMessage<UInt64Value> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 118);

/**
 * FilesystemIdentifier uniquely identify the filesystem.
 *
 * @generated from message runtime.v1.FilesystemIdentifier
 */
export type FilesystemIdentifier = Message<"runtime.v1.FilesystemIdentifier"> & {
  /**
   * Mountpoint of a filesystem.
   *
   * @generated from field: string mountpoint = 1;
   */
  mountpoint: string;
};

/**
 * Describes the message runtime.v1.FilesystemIdentifier.
 * Use `create(FilesystemIdentifierSchema)` to create a new message.
 */
export const FilesystemIdentifierSchema: GenMessage<FilesystemIdentifier> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 119);

/**
 * FilesystemUsage provides the filesystem usage information.
 *
 * @generated from message runtime.v1.FilesystemUsage
 */
export type FilesystemUsage = Message<"runtime.v1.FilesystemUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * The unique identifier of the filesystem.
   *
   * @generated from field: runtime.v1.FilesystemIdentifier fs_id = 2;
   */
  fsId?: FilesystemIdentifier;

  /**
   * UsedBytes represents the bytes used for images on the filesystem.
   * This may differ from the total bytes used on the filesystem and may not
   * equal CapacityBytes - AvailableBytes.
   *
   * @generated from field: runtime.v1.UInt64Value used_bytes = 3;
   */
  usedBytes?: UInt64Value;

  /**
   * InodesUsed represents the inodes used by the images.
   * This may not equal InodesCapacity - InodesAvailable because the underlying
   * filesystem may also be used for purposes other than storing images.
   *
   * @generated from field: runtime.v1.UInt64Value inodes_used = 4;
   */
  inodesUsed?: UInt64Value;
};

/**
 * Describes the message runtime.v1.FilesystemUsage.
 * Use `create(FilesystemUsageSchema)` to create a new message.
 */
export const FilesystemUsageSchema: GenMessage<FilesystemUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 120);

/**
 * WindowsFilesystemUsage provides the filesystem usage information specific to Windows.
 *
 * @generated from message runtime.v1.WindowsFilesystemUsage
 */
export type WindowsFilesystemUsage = Message<"runtime.v1.WindowsFilesystemUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * The unique identifier of the filesystem.
   *
   * @generated from field: runtime.v1.FilesystemIdentifier fs_id = 2;
   */
  fsId?: FilesystemIdentifier;

  /**
   * UsedBytes represents the bytes used for images on the filesystem.
   * This may differ from the total bytes used on the filesystem and may not
   * equal CapacityBytes - AvailableBytes.
   *
   * @generated from field: runtime.v1.UInt64Value used_bytes = 3;
   */
  usedBytes?: UInt64Value;
};

/**
 * Describes the message runtime.v1.WindowsFilesystemUsage.
 * Use `create(WindowsFilesystemUsageSchema)` to create a new message.
 */
export const WindowsFilesystemUsageSchema: GenMessage<WindowsFilesystemUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 121);

/**
 * @generated from message runtime.v1.ImageFsInfoResponse
 */
export type ImageFsInfoResponse = Message<"runtime.v1.ImageFsInfoResponse"> & {
  /**
   * Information of image filesystem(s).
   *
   * @generated from field: repeated runtime.v1.FilesystemUsage image_filesystems = 1;
   */
  imageFilesystems: FilesystemUsage[];

  /**
   * Information of container filesystem(s).
   * This is an optional field, may be used for example if container and image
   * storage are separated.
   * Default will be to return this as empty.
   *
   * @generated from field: repeated runtime.v1.FilesystemUsage container_filesystems = 2;
   */
  containerFilesystems: FilesystemUsage[];
};

/**
 * Describes the message runtime.v1.ImageFsInfoResponse.
 * Use `create(ImageFsInfoResponseSchema)` to create a new message.
 */
export const ImageFsInfoResponseSchema: GenMessage<ImageFsInfoResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 122);

/**
 * @generated from message runtime.v1.ContainerStatsRequest
 */
export type ContainerStatsRequest = Message<"runtime.v1.ContainerStatsRequest"> & {
  /**
   * ID of the container for which to retrieve stats.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;
};

/**
 * Describes the message runtime.v1.ContainerStatsRequest.
 * Use `create(ContainerStatsRequestSchema)` to create a new message.
 */
export const ContainerStatsRequestSchema: GenMessage<ContainerStatsRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 123);

/**
 * @generated from message runtime.v1.ContainerStatsResponse
 */
export type ContainerStatsResponse = Message<"runtime.v1.ContainerStatsResponse"> & {
  /**
   * Stats of the container.
   *
   * @generated from field: runtime.v1.ContainerStats stats = 1;
   */
  stats?: ContainerStats;
};

/**
 * Describes the message runtime.v1.ContainerStatsResponse.
 * Use `create(ContainerStatsResponseSchema)` to create a new message.
 */
export const ContainerStatsResponseSchema: GenMessage<ContainerStatsResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 124);

/**
 * @generated from message runtime.v1.ListContainerStatsRequest
 */
export type ListContainerStatsRequest = Message<"runtime.v1.ListContainerStatsRequest"> & {
  /**
   * Filter for the list request.
   *
   * @generated from field: runtime.v1.ContainerStatsFilter filter = 1;
   */
  filter?: ContainerStatsFilter;
};

/**
 * Describes the message runtime.v1.ListContainerStatsRequest.
 * Use `create(ListContainerStatsRequestSchema)` to create a new message.
 */
export const ListContainerStatsRequestSchema: GenMessage<ListContainerStatsRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 125);

/**
 * ContainerStatsFilter is used to filter containers.
 * All those fields are combined with 'AND'
 *
 * @generated from message runtime.v1.ContainerStatsFilter
 */
export type ContainerStatsFilter = Message<"runtime.v1.ContainerStatsFilter"> & {
  /**
   * ID of the container.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * ID of the PodSandbox.
   *
   * @generated from field: string pod_sandbox_id = 2;
   */
  podSandboxId: string;

  /**
   * LabelSelector to select matches.
   * Only api.MatchLabels is supported for now and the requirements
   * are ANDed. MatchExpressions is not supported yet.
   *
   * @generated from field: map<string, string> label_selector = 3;
   */
  labelSelector: { [key: string]: string };
};

/**
 * Describes the message runtime.v1.ContainerStatsFilter.
 * Use `create(ContainerStatsFilterSchema)` to create a new message.
 */
export const ContainerStatsFilterSchema: GenMessage<ContainerStatsFilter> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 126);

/**
 * @generated from message runtime.v1.ListContainerStatsResponse
 */
export type ListContainerStatsResponse = Message<"runtime.v1.ListContainerStatsResponse"> & {
  /**
   * Stats of the container.
   *
   * @generated from field: repeated runtime.v1.ContainerStats stats = 1;
   */
  stats: ContainerStats[];
};

/**
 * Describes the message runtime.v1.ListContainerStatsResponse.
 * Use `create(ListContainerStatsResponseSchema)` to create a new message.
 */
export const ListContainerStatsResponseSchema: GenMessage<ListContainerStatsResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 127);

/**
 * ContainerAttributes provides basic information of the container.
 *
 * @generated from message runtime.v1.ContainerAttributes
 */
export type ContainerAttributes = Message<"runtime.v1.ContainerAttributes"> & {
  /**
   * ID of the container.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Metadata of the container.
   *
   * @generated from field: runtime.v1.ContainerMetadata metadata = 2;
   */
  metadata?: ContainerMetadata;

  /**
   * Key-value pairs that may be used to scope and select individual resources.
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };

  /**
   * Unstructured key-value map holding arbitrary metadata.
   * Annotations MUST NOT be altered by the runtime; the value of this field
   * MUST be identical to that of the corresponding ContainerConfig used to
   * instantiate the Container this status represents.
   *
   * @generated from field: map<string, string> annotations = 4;
   */
  annotations: { [key: string]: string };
};

/**
 * Describes the message runtime.v1.ContainerAttributes.
 * Use `create(ContainerAttributesSchema)` to create a new message.
 */
export const ContainerAttributesSchema: GenMessage<ContainerAttributes> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 128);

/**
 * ContainerStats provides the resource usage statistics for a container.
 *
 * @generated from message runtime.v1.ContainerStats
 */
export type ContainerStats = Message<"runtime.v1.ContainerStats"> & {
  /**
   * Information of the container.
   *
   * @generated from field: runtime.v1.ContainerAttributes attributes = 1;
   */
  attributes?: ContainerAttributes;

  /**
   * CPU usage gathered from the container.
   *
   * @generated from field: runtime.v1.CpuUsage cpu = 2;
   */
  cpu?: CpuUsage;

  /**
   * Memory usage gathered from the container.
   *
   * @generated from field: runtime.v1.MemoryUsage memory = 3;
   */
  memory?: MemoryUsage;

  /**
   * Usage of the writable layer.
   *
   * @generated from field: runtime.v1.FilesystemUsage writable_layer = 4;
   */
  writableLayer?: FilesystemUsage;

  /**
   * Swap usage gathered from the container.
   *
   * @generated from field: runtime.v1.SwapUsage swap = 5;
   */
  swap?: SwapUsage;

  /**
   * IO usage gathered from the container.
   *
   * @generated from field: runtime.v1.IoUsage io = 6;
   */
  io?: IoUsage;
};

/**
 * Describes the message runtime.v1.ContainerStats.
 * Use `create(ContainerStatsSchema)` to create a new message.
 */
export const ContainerStatsSchema: GenMessage<ContainerStats> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 129);

/**
 * WindowsContainerStats provides the resource usage statistics for a container specific for Windows
 *
 * @generated from message runtime.v1.WindowsContainerStats
 */
export type WindowsContainerStats = Message<"runtime.v1.WindowsContainerStats"> & {
  /**
   * Information of the container.
   *
   * @generated from field: runtime.v1.ContainerAttributes attributes = 1;
   */
  attributes?: ContainerAttributes;

  /**
   * CPU usage gathered from the container.
   *
   * @generated from field: runtime.v1.WindowsCpuUsage cpu = 2;
   */
  cpu?: WindowsCpuUsage;

  /**
   * Memory usage gathered from the container.
   *
   * @generated from field: runtime.v1.WindowsMemoryUsage memory = 3;
   */
  memory?: WindowsMemoryUsage;

  /**
   * Usage of the writable layer.
   *
   * @generated from field: runtime.v1.WindowsFilesystemUsage writable_layer = 4;
   */
  writableLayer?: WindowsFilesystemUsage;
};

/**
 * Describes the message runtime.v1.WindowsContainerStats.
 * Use `create(WindowsContainerStatsSchema)` to create a new message.
 */
export const WindowsContainerStatsSchema: GenMessage<WindowsContainerStats> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 130);

/**
 * PSI statistics for an individual resource.
 *
 * @generated from message runtime.v1.PsiStats
 */
export type PsiStats = Message<"runtime.v1.PsiStats"> & {
  /**
   * PSI data for all tasks in the cgroup.
   *
   * @generated from field: runtime.v1.PsiData Full = 1;
   */
  Full?: PsiData;

  /**
   * PSI data for some tasks in the cgroup.
   *
   * @generated from field: runtime.v1.PsiData Some = 2;
   */
  Some?: PsiData;
};

/**
 * Describes the message runtime.v1.PsiStats.
 * Use `create(PsiStatsSchema)` to create a new message.
 */
export const PsiStatsSchema: GenMessage<PsiStats> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 131);

/**
 * PSI data for an individual resource.
 *
 * @generated from message runtime.v1.PsiData
 */
export type PsiData = Message<"runtime.v1.PsiData"> & {
  /**
   * Total time duration for tasks in the cgroup have waited due to congestion.
   * Unit: nanoseconds.
   *
   * @generated from field: uint64 Total = 1;
   */
  Total: bigint;

  /**
   * The average (in %) tasks have waited due to congestion over a 10 second window.
   *
   * @generated from field: double Avg10 = 2;
   */
  Avg10: number;

  /**
   * The average (in %) tasks have waited due to congestion over a 60 second window.
   *
   * @generated from field: double Avg60 = 3;
   */
  Avg60: number;

  /**
   * The average (in %) tasks have waited due to congestion over a 300 second window.
   *
   * @generated from field: double Avg300 = 4;
   */
  Avg300: number;
};

/**
 * Describes the message runtime.v1.PsiData.
 * Use `create(PsiDataSchema)` to create a new message.
 */
export const PsiDataSchema: GenMessage<PsiData> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 132);

/**
 * CpuUsage provides the CPU usage information.
 *
 * @generated from message runtime.v1.CpuUsage
 */
export type CpuUsage = Message<"runtime.v1.CpuUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * Cumulative CPU usage (sum across all cores) since object creation.
   *
   * @generated from field: runtime.v1.UInt64Value usage_core_nano_seconds = 2;
   */
  usageCoreNanoSeconds?: UInt64Value;

  /**
   * Total CPU usage (sum of all cores) averaged over the sample window.
   * The "core" unit can be interpreted as CPU core-nanoseconds per second.
   *
   * @generated from field: runtime.v1.UInt64Value usage_nano_cores = 3;
   */
  usageNanoCores?: UInt64Value;

  /**
   * CPU PSI statistics.
   *
   * @generated from field: runtime.v1.PsiStats psi = 4;
   */
  psi?: PsiStats;
};

/**
 * Describes the message runtime.v1.CpuUsage.
 * Use `create(CpuUsageSchema)` to create a new message.
 */
export const CpuUsageSchema: GenMessage<CpuUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 133);

/**
 * WindowsCpuUsage provides the CPU usage information specific to Windows
 *
 * @generated from message runtime.v1.WindowsCpuUsage
 */
export type WindowsCpuUsage = Message<"runtime.v1.WindowsCpuUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * Cumulative CPU usage (sum across all cores) since object creation.
   *
   * @generated from field: runtime.v1.UInt64Value usage_core_nano_seconds = 2;
   */
  usageCoreNanoSeconds?: UInt64Value;

  /**
   * Total CPU usage (sum of all cores) averaged over the sample window.
   * The "core" unit can be interpreted as CPU core-nanoseconds per second.
   *
   * @generated from field: runtime.v1.UInt64Value usage_nano_cores = 3;
   */
  usageNanoCores?: UInt64Value;
};

/**
 * Describes the message runtime.v1.WindowsCpuUsage.
 * Use `create(WindowsCpuUsageSchema)` to create a new message.
 */
export const WindowsCpuUsageSchema: GenMessage<WindowsCpuUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 134);

/**
 * MemoryUsage provides the memory usage information.
 *
 * @generated from message runtime.v1.MemoryUsage
 */
export type MemoryUsage = Message<"runtime.v1.MemoryUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * The amount of working set memory in bytes.
   *
   * @generated from field: runtime.v1.UInt64Value working_set_bytes = 2;
   */
  workingSetBytes?: UInt64Value;

  /**
   * Available memory for use. This is defined as the memory limit - workingSetBytes.
   *
   * @generated from field: runtime.v1.UInt64Value available_bytes = 3;
   */
  availableBytes?: UInt64Value;

  /**
   * Total memory in use. This includes all memory regardless of when it was accessed.
   *
   * @generated from field: runtime.v1.UInt64Value usage_bytes = 4;
   */
  usageBytes?: UInt64Value;

  /**
   * The amount of anonymous and swap cache memory (includes transparent hugepages).
   *
   * @generated from field: runtime.v1.UInt64Value rss_bytes = 5;
   */
  rssBytes?: UInt64Value;

  /**
   * Cumulative number of minor page faults.
   *
   * @generated from field: runtime.v1.UInt64Value page_faults = 6;
   */
  pageFaults?: UInt64Value;

  /**
   * Cumulative number of major page faults.
   *
   * @generated from field: runtime.v1.UInt64Value major_page_faults = 7;
   */
  majorPageFaults?: UInt64Value;

  /**
   * Memory PSI statistics.
   *
   * @generated from field: runtime.v1.PsiStats psi = 8;
   */
  psi?: PsiStats;
};

/**
 * Describes the message runtime.v1.MemoryUsage.
 * Use `create(MemoryUsageSchema)` to create a new message.
 */
export const MemoryUsageSchema: GenMessage<MemoryUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 135);

/**
 * @generated from message runtime.v1.IoUsage
 */
export type IoUsage = Message<"runtime.v1.IoUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * IO PSI statistics.
   *
   * @generated from field: runtime.v1.PsiStats psi = 2;
   */
  psi?: PsiStats;
};

/**
 * Describes the message runtime.v1.IoUsage.
 * Use `create(IoUsageSchema)` to create a new message.
 */
export const IoUsageSchema: GenMessage<IoUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 136);

/**
 * @generated from message runtime.v1.SwapUsage
 */
export type SwapUsage = Message<"runtime.v1.SwapUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * Available swap for use. This is defined as the swap limit - swapUsageBytes.
   *
   * @generated from field: runtime.v1.UInt64Value swap_available_bytes = 2;
   */
  swapAvailableBytes?: UInt64Value;

  /**
   * Total memory in use. This includes all memory regardless of when it was accessed.
   *
   * @generated from field: runtime.v1.UInt64Value swap_usage_bytes = 3;
   */
  swapUsageBytes?: UInt64Value;
};

/**
 * Describes the message runtime.v1.SwapUsage.
 * Use `create(SwapUsageSchema)` to create a new message.
 */
export const SwapUsageSchema: GenMessage<SwapUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 137);

/**
 * WindowsMemoryUsage provides the memory usage information specific to Windows
 *
 * @generated from message runtime.v1.WindowsMemoryUsage
 */
export type WindowsMemoryUsage = Message<"runtime.v1.WindowsMemoryUsage"> & {
  /**
   * Timestamp in nanoseconds at which the information were collected. Must be > 0.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * The amount of working set memory in bytes.
   *
   * @generated from field: runtime.v1.UInt64Value working_set_bytes = 2;
   */
  workingSetBytes?: UInt64Value;

  /**
   * Available memory for use. This is defined as the memory limit - commit_memory_bytes.
   *
   * @generated from field: runtime.v1.UInt64Value available_bytes = 3;
   */
  availableBytes?: UInt64Value;

  /**
   * Cumulative number of page faults.
   *
   * @generated from field: runtime.v1.UInt64Value page_faults = 4;
   */
  pageFaults?: UInt64Value;

  /**
   * Total commit memory in use. Commit memory is total of physical and virtual memory in use.
   *
   * @generated from field: runtime.v1.UInt64Value commit_memory_bytes = 5;
   */
  commitMemoryBytes?: UInt64Value;
};

/**
 * Describes the message runtime.v1.WindowsMemoryUsage.
 * Use `create(WindowsMemoryUsageSchema)` to create a new message.
 */
export const WindowsMemoryUsageSchema: GenMessage<WindowsMemoryUsage> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 138);

/**
 * @generated from message runtime.v1.ReopenContainerLogRequest
 */
export type ReopenContainerLogRequest = Message<"runtime.v1.ReopenContainerLogRequest"> & {
  /**
   * ID of the container for which to reopen the log.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;
};

/**
 * Describes the message runtime.v1.ReopenContainerLogRequest.
 * Use `create(ReopenContainerLogRequestSchema)` to create a new message.
 */
export const ReopenContainerLogRequestSchema: GenMessage<ReopenContainerLogRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 139);

/**
 * @generated from message runtime.v1.ReopenContainerLogResponse
 */
export type ReopenContainerLogResponse = Message<"runtime.v1.ReopenContainerLogResponse"> & {
};

/**
 * Describes the message runtime.v1.ReopenContainerLogResponse.
 * Use `create(ReopenContainerLogResponseSchema)` to create a new message.
 */
export const ReopenContainerLogResponseSchema: GenMessage<ReopenContainerLogResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 140);

/**
 * @generated from message runtime.v1.CheckpointContainerRequest
 */
export type CheckpointContainerRequest = Message<"runtime.v1.CheckpointContainerRequest"> & {
  /**
   * ID of the container to be checkpointed.
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;

  /**
   * Location of the checkpoint archive used for export
   *
   * @generated from field: string location = 2;
   */
  location: string;

  /**
   * Timeout in seconds for the checkpoint to complete.
   * Timeout of zero means to use the CRI default.
   * Timeout > 0 means to use the user specified timeout.
   *
   * @generated from field: int64 timeout = 3;
   */
  timeout: bigint;
};

/**
 * Describes the message runtime.v1.CheckpointContainerRequest.
 * Use `create(CheckpointContainerRequestSchema)` to create a new message.
 */
export const CheckpointContainerRequestSchema: GenMessage<CheckpointContainerRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 141);

/**
 * @generated from message runtime.v1.CheckpointContainerResponse
 */
export type CheckpointContainerResponse = Message<"runtime.v1.CheckpointContainerResponse"> & {
};

/**
 * Describes the message runtime.v1.CheckpointContainerResponse.
 * Use `create(CheckpointContainerResponseSchema)` to create a new message.
 */
export const CheckpointContainerResponseSchema: GenMessage<CheckpointContainerResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 142);

/**
 * @generated from message runtime.v1.GetEventsRequest
 */
export type GetEventsRequest = Message<"runtime.v1.GetEventsRequest"> & {
};

/**
 * Describes the message runtime.v1.GetEventsRequest.
 * Use `create(GetEventsRequestSchema)` to create a new message.
 */
export const GetEventsRequestSchema: GenMessage<GetEventsRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 143);

/**
 * @generated from message runtime.v1.ContainerEventResponse
 */
export type ContainerEventResponse = Message<"runtime.v1.ContainerEventResponse"> & {
  /**
   * ID of the container
   *
   * @generated from field: string container_id = 1;
   */
  containerId: string;

  /**
   * Type of the container event
   *
   * @generated from field: runtime.v1.ContainerEventType container_event_type = 2;
   */
  containerEventType: ContainerEventType;

  /**
   * Creation timestamp in nanoseconds of this event
   *
   * @generated from field: int64 created_at = 3;
   */
  createdAt: bigint;

  /**
   * Sandbox status
   *
   * @generated from field: runtime.v1.PodSandboxStatus pod_sandbox_status = 4;
   */
  podSandboxStatus?: PodSandboxStatus;

  /**
   * Container statuses
   *
   * @generated from field: repeated runtime.v1.ContainerStatus containers_statuses = 5;
   */
  containersStatuses: ContainerStatus[];
};

/**
 * Describes the message runtime.v1.ContainerEventResponse.
 * Use `create(ContainerEventResponseSchema)` to create a new message.
 */
export const ContainerEventResponseSchema: GenMessage<ContainerEventResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 144);

/**
 * @generated from message runtime.v1.ListMetricDescriptorsRequest
 */
export type ListMetricDescriptorsRequest = Message<"runtime.v1.ListMetricDescriptorsRequest"> & {
};

/**
 * Describes the message runtime.v1.ListMetricDescriptorsRequest.
 * Use `create(ListMetricDescriptorsRequestSchema)` to create a new message.
 */
export const ListMetricDescriptorsRequestSchema: GenMessage<ListMetricDescriptorsRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 145);

/**
 * @generated from message runtime.v1.ListMetricDescriptorsResponse
 */
export type ListMetricDescriptorsResponse = Message<"runtime.v1.ListMetricDescriptorsResponse"> & {
  /**
   * @generated from field: repeated runtime.v1.MetricDescriptor descriptors = 1;
   */
  descriptors: MetricDescriptor[];
};

/**
 * Describes the message runtime.v1.ListMetricDescriptorsResponse.
 * Use `create(ListMetricDescriptorsResponseSchema)` to create a new message.
 */
export const ListMetricDescriptorsResponseSchema: GenMessage<ListMetricDescriptorsResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 146);

/**
 * @generated from message runtime.v1.MetricDescriptor
 */
export type MetricDescriptor = Message<"runtime.v1.MetricDescriptor"> & {
  /**
   * The name field will be used as a unique identifier of this MetricDescriptor,
   * and be used in conjunction with the Metric structure to populate the full Metric.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string help = 2;
   */
  help: string;

  /**
   * When a metric uses this metric descriptor, it should only define
   * labels that have previously been declared in label_keys.
   * It is the responsibility of the runtime to correctly keep sorted the keys and values.
   * If the two slices have different length, the behavior is undefined.
   *
   * @generated from field: repeated string label_keys = 3;
   */
  labelKeys: string[];
};

/**
 * Describes the message runtime.v1.MetricDescriptor.
 * Use `create(MetricDescriptorSchema)` to create a new message.
 */
export const MetricDescriptorSchema: GenMessage<MetricDescriptor> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 147);

/**
 * @generated from message runtime.v1.ListPodSandboxMetricsRequest
 */
export type ListPodSandboxMetricsRequest = Message<"runtime.v1.ListPodSandboxMetricsRequest"> & {
};

/**
 * Describes the message runtime.v1.ListPodSandboxMetricsRequest.
 * Use `create(ListPodSandboxMetricsRequestSchema)` to create a new message.
 */
export const ListPodSandboxMetricsRequestSchema: GenMessage<ListPodSandboxMetricsRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 148);

/**
 * @generated from message runtime.v1.ListPodSandboxMetricsResponse
 */
export type ListPodSandboxMetricsResponse = Message<"runtime.v1.ListPodSandboxMetricsResponse"> & {
  /**
   * @generated from field: repeated runtime.v1.PodSandboxMetrics pod_metrics = 1;
   */
  podMetrics: PodSandboxMetrics[];
};

/**
 * Describes the message runtime.v1.ListPodSandboxMetricsResponse.
 * Use `create(ListPodSandboxMetricsResponseSchema)` to create a new message.
 */
export const ListPodSandboxMetricsResponseSchema: GenMessage<ListPodSandboxMetricsResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 149);

/**
 * @generated from message runtime.v1.PodSandboxMetrics
 */
export type PodSandboxMetrics = Message<"runtime.v1.PodSandboxMetrics"> & {
  /**
   * @generated from field: string pod_sandbox_id = 1;
   */
  podSandboxId: string;

  /**
   * @generated from field: repeated runtime.v1.Metric metrics = 2;
   */
  metrics: Metric[];

  /**
   * @generated from field: repeated runtime.v1.ContainerMetrics container_metrics = 3;
   */
  containerMetrics: ContainerMetrics[];
};

/**
 * Describes the message runtime.v1.PodSandboxMetrics.
 * Use `create(PodSandboxMetricsSchema)` to create a new message.
 */
export const PodSandboxMetricsSchema: GenMessage<PodSandboxMetrics> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 150);

/**
 * @generated from message runtime.v1.ContainerMetrics
 */
export type ContainerMetrics = Message<"runtime.v1.ContainerMetrics"> & {
  /**
   * @generated from field: string container_id = 1;
   */
  containerId: string;

  /**
   * @generated from field: repeated runtime.v1.Metric metrics = 2;
   */
  metrics: Metric[];
};

/**
 * Describes the message runtime.v1.ContainerMetrics.
 * Use `create(ContainerMetricsSchema)` to create a new message.
 */
export const ContainerMetricsSchema: GenMessage<ContainerMetrics> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 151);

/**
 * @generated from message runtime.v1.Metric
 */
export type Metric = Message<"runtime.v1.Metric"> & {
  /**
   * Name must match a name previously returned in a MetricDescriptors call,
   * otherwise, it will be ignored.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Timestamp should be 0 if the metric was gathered live.
   * If it was cached, the Timestamp should reflect the time in nanoseconds it was collected.
   *
   * @generated from field: int64 timestamp = 2;
   */
  timestamp: bigint;

  /**
   * @generated from field: runtime.v1.MetricType metric_type = 3;
   */
  metricType: MetricType;

  /**
   * The corresponding LabelValues to the LabelKeys defined in the MetricDescriptor.
   * It is the responsibility of the runtime to correctly keep sorted the keys and values.
   * If the two slices have different length, the behavior is undefined.
   *
   * @generated from field: repeated string label_values = 4;
   */
  labelValues: string[];

  /**
   * @generated from field: runtime.v1.UInt64Value value = 5;
   */
  value?: UInt64Value;
};

/**
 * Describes the message runtime.v1.Metric.
 * Use `create(MetricSchema)` to create a new message.
 */
export const MetricSchema: GenMessage<Metric> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 152);

/**
 * @generated from message runtime.v1.RuntimeConfigRequest
 */
export type RuntimeConfigRequest = Message<"runtime.v1.RuntimeConfigRequest"> & {
};

/**
 * Describes the message runtime.v1.RuntimeConfigRequest.
 * Use `create(RuntimeConfigRequestSchema)` to create a new message.
 */
export const RuntimeConfigRequestSchema: GenMessage<RuntimeConfigRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 153);

/**
 * @generated from message runtime.v1.RuntimeConfigResponse
 */
export type RuntimeConfigResponse = Message<"runtime.v1.RuntimeConfigResponse"> & {
  /**
   * Configuration information for Linux-based runtimes. This field contains
   * global runtime configuration options that are not specific to runtime
   * handlers.
   *
   * @generated from field: runtime.v1.LinuxRuntimeConfiguration linux = 1;
   */
  linux?: LinuxRuntimeConfiguration;
};

/**
 * Describes the message runtime.v1.RuntimeConfigResponse.
 * Use `create(RuntimeConfigResponseSchema)` to create a new message.
 */
export const RuntimeConfigResponseSchema: GenMessage<RuntimeConfigResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 154);

/**
 * @generated from message runtime.v1.LinuxRuntimeConfiguration
 */
export type LinuxRuntimeConfiguration = Message<"runtime.v1.LinuxRuntimeConfiguration"> & {
  /**
   * Cgroup driver to use
   * Note: this field should not change for the lifecycle of the Kubelet,
   * or while there are running containers.
   * The Kubelet will not re-request this after startup, and will construct the cgroup
   * hierarchy assuming it is static.
   * If the runtime wishes to change this value, it must be accompanied by removal of
   * all pods, and a restart of the Kubelet. The easiest way to do this is with a full node reboot.
   *
   * @generated from field: runtime.v1.CgroupDriver cgroup_driver = 1;
   */
  cgroupDriver: CgroupDriver;
};

/**
 * Describes the message runtime.v1.LinuxRuntimeConfiguration.
 * Use `create(LinuxRuntimeConfigurationSchema)` to create a new message.
 */
export const LinuxRuntimeConfigurationSchema: GenMessage<LinuxRuntimeConfiguration> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 155);

/**
 * @generated from message runtime.v1.UpdatePodSandboxResourcesRequest
 */
export type UpdatePodSandboxResourcesRequest = Message<"runtime.v1.UpdatePodSandboxResourcesRequest"> & {
  /**
   * ID of the PodSandbox to update.
   *
   * @generated from field: string pod_sandbox_id = 1;
   */
  podSandboxId: string;

  /**
   * Optional overhead represents the overheads associated with this sandbox
   *
   * @generated from field: runtime.v1.LinuxContainerResources overhead = 2;
   */
  overhead?: LinuxContainerResources;

  /**
   * Optional resources represents the sum of container resources for this sandbox
   *
   * @generated from field: runtime.v1.LinuxContainerResources resources = 3;
   */
  resources?: LinuxContainerResources;
};

/**
 * Describes the message runtime.v1.UpdatePodSandboxResourcesRequest.
 * Use `create(UpdatePodSandboxResourcesRequestSchema)` to create a new message.
 */
export const UpdatePodSandboxResourcesRequestSchema: GenMessage<UpdatePodSandboxResourcesRequest> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 156);

/**
 * @generated from message runtime.v1.UpdatePodSandboxResourcesResponse
 */
export type UpdatePodSandboxResourcesResponse = Message<"runtime.v1.UpdatePodSandboxResourcesResponse"> & {
};

/**
 * Describes the message runtime.v1.UpdatePodSandboxResourcesResponse.
 * Use `create(UpdatePodSandboxResourcesResponseSchema)` to create a new message.
 */
export const UpdatePodSandboxResourcesResponseSchema: GenMessage<UpdatePodSandboxResourcesResponse> = /*@__PURE__*/
  messageDesc(file_cri_api_pkg_apis_runtime_v1_api, 157);

/**
 * @generated from enum runtime.v1.Protocol
 */
export enum Protocol {
  /**
   * @generated from enum value: TCP = 0;
   */
  TCP = 0,

  /**
   * @generated from enum value: UDP = 1;
   */
  UDP = 1,

  /**
   * @generated from enum value: SCTP = 2;
   */
  SCTP = 2,
}

/**
 * Describes the enum runtime.v1.Protocol.
 */
export const ProtocolSchema: GenEnum<Protocol> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 0);

/**
 * @generated from enum runtime.v1.MountPropagation
 */
export enum MountPropagation {
  /**
   * No mount propagation ("rprivate" in Linux terminology).
   *
   * @generated from enum value: PROPAGATION_PRIVATE = 0;
   */
  PROPAGATION_PRIVATE = 0,

  /**
   * Mounts get propagated from the host to the container ("rslave" in Linux).
   *
   * @generated from enum value: PROPAGATION_HOST_TO_CONTAINER = 1;
   */
  PROPAGATION_HOST_TO_CONTAINER = 1,

  /**
   * Mounts get propagated from the host to the container and from the
   * container to the host ("rshared" in Linux).
   *
   * @generated from enum value: PROPAGATION_BIDIRECTIONAL = 2;
   */
  PROPAGATION_BIDIRECTIONAL = 2,
}

/**
 * Describes the enum runtime.v1.MountPropagation.
 */
export const MountPropagationSchema: GenEnum<MountPropagation> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 1);

/**
 * A NamespaceMode describes the intended namespace configuration for each
 * of the namespaces (Network, PID, IPC) in NamespaceOption. Runtimes should
 * map these modes as appropriate for the technology underlying the runtime.
 *
 * @generated from enum runtime.v1.NamespaceMode
 */
export enum NamespaceMode {
  /**
   * A POD namespace is common to all containers in a pod.
   * For example, a container with a PID namespace of POD expects to view
   * all of the processes in all of the containers in the pod.
   *
   * @generated from enum value: POD = 0;
   */
  POD = 0,

  /**
   * A CONTAINER namespace is restricted to a single container.
   * For example, a container with a PID namespace of CONTAINER expects to
   * view only the processes in that container.
   *
   * @generated from enum value: CONTAINER = 1;
   */
  CONTAINER = 1,

  /**
   * A NODE namespace is the namespace of the Kubernetes node.
   * For example, a container with a PID namespace of NODE expects to view
   * all of the processes on the host running the kubelet.
   *
   * @generated from enum value: NODE = 2;
   */
  NODE = 2,

  /**
   * TARGET targets the namespace of another container. When this is specified,
   * a target_id must be specified in NamespaceOption and refer to a container
   * previously created with NamespaceMode CONTAINER. This containers namespace
   * will be made to match that of container target_id.
   * For example, a container with a PID namespace of TARGET expects to view
   * all of the processes that container target_id can view.
   *
   * @generated from enum value: TARGET = 3;
   */
  TARGET = 3,
}

/**
 * Describes the enum runtime.v1.NamespaceMode.
 */
export const NamespaceModeSchema: GenEnum<NamespaceMode> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 2);

/**
 * SupplementalGroupsPolicy defines how supplemental groups 
 * of the first container processes are calculated.
 *
 * @generated from enum runtime.v1.SupplementalGroupsPolicy
 */
export enum SupplementalGroupsPolicy {
  /**
   * Merge means that the container's provided SupplementalGroups 
   * and FsGroup (specified in SecurityContext) will be merged with 
   * the primary user's groups as defined in the container image
   * (in /etc/group).
   *
   * @generated from enum value: Merge = 0;
   */
  Merge = 0,

  /**
   * Strict means that the container's provided SupplementalGroups
   * and FsGroup (specified in SecurityContext) will be used instead of 
   * any groups defined in the container image.
   *
   * @generated from enum value: Strict = 1;
   */
  Strict = 1,
}

/**
 * Describes the enum runtime.v1.SupplementalGroupsPolicy.
 */
export const SupplementalGroupsPolicySchema: GenEnum<SupplementalGroupsPolicy> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 3);

/**
 * @generated from enum runtime.v1.PodSandboxState
 */
export enum PodSandboxState {
  /**
   * @generated from enum value: SANDBOX_READY = 0;
   */
  SANDBOX_READY = 0,

  /**
   * @generated from enum value: SANDBOX_NOTREADY = 1;
   */
  SANDBOX_NOTREADY = 1,
}

/**
 * Describes the enum runtime.v1.PodSandboxState.
 */
export const PodSandboxStateSchema: GenEnum<PodSandboxState> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 4);

/**
 * @generated from enum runtime.v1.Signal
 */
export enum Signal {
  /**
   * @generated from enum value: RUNTIME_DEFAULT = 0;
   */
  RUNTIME_DEFAULT = 0,

  /**
   * @generated from enum value: SIGABRT = 1;
   */
  SIGABRT = 1,

  /**
   * @generated from enum value: SIGALRM = 2;
   */
  SIGALRM = 2,

  /**
   * @generated from enum value: SIGBUS = 3;
   */
  SIGBUS = 3,

  /**
   * @generated from enum value: SIGCHLD = 4;
   */
  SIGCHLD = 4,

  /**
   * @generated from enum value: SIGCLD = 5;
   */
  SIGCLD = 5,

  /**
   * @generated from enum value: SIGCONT = 6;
   */
  SIGCONT = 6,

  /**
   * @generated from enum value: SIGFPE = 7;
   */
  SIGFPE = 7,

  /**
   * @generated from enum value: SIGHUP = 8;
   */
  SIGHUP = 8,

  /**
   * @generated from enum value: SIGILL = 9;
   */
  SIGILL = 9,

  /**
   * @generated from enum value: SIGINT = 10;
   */
  SIGINT = 10,

  /**
   * @generated from enum value: SIGIO = 11;
   */
  SIGIO = 11,

  /**
   * @generated from enum value: SIGIOT = 12;
   */
  SIGIOT = 12,

  /**
   * @generated from enum value: SIGKILL = 13;
   */
  SIGKILL = 13,

  /**
   * @generated from enum value: SIGPIPE = 14;
   */
  SIGPIPE = 14,

  /**
   * @generated from enum value: SIGPOLL = 15;
   */
  SIGPOLL = 15,

  /**
   * @generated from enum value: SIGPROF = 16;
   */
  SIGPROF = 16,

  /**
   * @generated from enum value: SIGPWR = 17;
   */
  SIGPWR = 17,

  /**
   * @generated from enum value: SIGQUIT = 18;
   */
  SIGQUIT = 18,

  /**
   * @generated from enum value: SIGSEGV = 19;
   */
  SIGSEGV = 19,

  /**
   * @generated from enum value: SIGSTKFLT = 20;
   */
  SIGSTKFLT = 20,

  /**
   * @generated from enum value: SIGSTOP = 21;
   */
  SIGSTOP = 21,

  /**
   * @generated from enum value: SIGSYS = 22;
   */
  SIGSYS = 22,

  /**
   * @generated from enum value: SIGTERM = 23;
   */
  SIGTERM = 23,

  /**
   * @generated from enum value: SIGTRAP = 24;
   */
  SIGTRAP = 24,

  /**
   * @generated from enum value: SIGTSTP = 25;
   */
  SIGTSTP = 25,

  /**
   * @generated from enum value: SIGTTIN = 26;
   */
  SIGTTIN = 26,

  /**
   * @generated from enum value: SIGTTOU = 27;
   */
  SIGTTOU = 27,

  /**
   * @generated from enum value: SIGURG = 28;
   */
  SIGURG = 28,

  /**
   * @generated from enum value: SIGUSR1 = 29;
   */
  SIGUSR1 = 29,

  /**
   * @generated from enum value: SIGUSR2 = 30;
   */
  SIGUSR2 = 30,

  /**
   * @generated from enum value: SIGVTALRM = 31;
   */
  SIGVTALRM = 31,

  /**
   * @generated from enum value: SIGWINCH = 32;
   */
  SIGWINCH = 32,

  /**
   * @generated from enum value: SIGXCPU = 33;
   */
  SIGXCPU = 33,

  /**
   * @generated from enum value: SIGXFSZ = 34;
   */
  SIGXFSZ = 34,

  /**
   * @generated from enum value: SIGRTMIN = 35;
   */
  SIGRTMIN = 35,

  /**
   * @generated from enum value: SIGRTMINPLUS1 = 36;
   */
  SIGRTMINPLUS1 = 36,

  /**
   * @generated from enum value: SIGRTMINPLUS2 = 37;
   */
  SIGRTMINPLUS2 = 37,

  /**
   * @generated from enum value: SIGRTMINPLUS3 = 38;
   */
  SIGRTMINPLUS3 = 38,

  /**
   * @generated from enum value: SIGRTMINPLUS4 = 39;
   */
  SIGRTMINPLUS4 = 39,

  /**
   * @generated from enum value: SIGRTMINPLUS5 = 40;
   */
  SIGRTMINPLUS5 = 40,

  /**
   * @generated from enum value: SIGRTMINPLUS6 = 41;
   */
  SIGRTMINPLUS6 = 41,

  /**
   * @generated from enum value: SIGRTMINPLUS7 = 42;
   */
  SIGRTMINPLUS7 = 42,

  /**
   * @generated from enum value: SIGRTMINPLUS8 = 43;
   */
  SIGRTMINPLUS8 = 43,

  /**
   * @generated from enum value: SIGRTMINPLUS9 = 44;
   */
  SIGRTMINPLUS9 = 44,

  /**
   * @generated from enum value: SIGRTMINPLUS10 = 45;
   */
  SIGRTMINPLUS10 = 45,

  /**
   * @generated from enum value: SIGRTMINPLUS11 = 46;
   */
  SIGRTMINPLUS11 = 46,

  /**
   * @generated from enum value: SIGRTMINPLUS12 = 47;
   */
  SIGRTMINPLUS12 = 47,

  /**
   * @generated from enum value: SIGRTMINPLUS13 = 48;
   */
  SIGRTMINPLUS13 = 48,

  /**
   * @generated from enum value: SIGRTMINPLUS14 = 49;
   */
  SIGRTMINPLUS14 = 49,

  /**
   * @generated from enum value: SIGRTMINPLUS15 = 50;
   */
  SIGRTMINPLUS15 = 50,

  /**
   * @generated from enum value: SIGRTMAXMINUS14 = 51;
   */
  SIGRTMAXMINUS14 = 51,

  /**
   * @generated from enum value: SIGRTMAXMINUS13 = 52;
   */
  SIGRTMAXMINUS13 = 52,

  /**
   * @generated from enum value: SIGRTMAXMINUS12 = 53;
   */
  SIGRTMAXMINUS12 = 53,

  /**
   * @generated from enum value: SIGRTMAXMINUS11 = 54;
   */
  SIGRTMAXMINUS11 = 54,

  /**
   * @generated from enum value: SIGRTMAXMINUS10 = 55;
   */
  SIGRTMAXMINUS10 = 55,

  /**
   * @generated from enum value: SIGRTMAXMINUS9 = 56;
   */
  SIGRTMAXMINUS9 = 56,

  /**
   * @generated from enum value: SIGRTMAXMINUS8 = 57;
   */
  SIGRTMAXMINUS8 = 57,

  /**
   * @generated from enum value: SIGRTMAXMINUS7 = 58;
   */
  SIGRTMAXMINUS7 = 58,

  /**
   * @generated from enum value: SIGRTMAXMINUS6 = 59;
   */
  SIGRTMAXMINUS6 = 59,

  /**
   * @generated from enum value: SIGRTMAXMINUS5 = 60;
   */
  SIGRTMAXMINUS5 = 60,

  /**
   * @generated from enum value: SIGRTMAXMINUS4 = 61;
   */
  SIGRTMAXMINUS4 = 61,

  /**
   * @generated from enum value: SIGRTMAXMINUS3 = 62;
   */
  SIGRTMAXMINUS3 = 62,

  /**
   * @generated from enum value: SIGRTMAXMINUS2 = 63;
   */
  SIGRTMAXMINUS2 = 63,

  /**
   * @generated from enum value: SIGRTMAXMINUS1 = 64;
   */
  SIGRTMAXMINUS1 = 64,

  /**
   * @generated from enum value: SIGRTMAX = 65;
   */
  SIGRTMAX = 65,
}

/**
 * Describes the enum runtime.v1.Signal.
 */
export const SignalSchema: GenEnum<Signal> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 5);

/**
 * @generated from enum runtime.v1.ContainerState
 */
export enum ContainerState {
  /**
   * @generated from enum value: CONTAINER_CREATED = 0;
   */
  CONTAINER_CREATED = 0,

  /**
   * @generated from enum value: CONTAINER_RUNNING = 1;
   */
  CONTAINER_RUNNING = 1,

  /**
   * @generated from enum value: CONTAINER_EXITED = 2;
   */
  CONTAINER_EXITED = 2,

  /**
   * @generated from enum value: CONTAINER_UNKNOWN = 3;
   */
  CONTAINER_UNKNOWN = 3,
}

/**
 * Describes the enum runtime.v1.ContainerState.
 */
export const ContainerStateSchema: GenEnum<ContainerState> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 6);

/**
 * @generated from enum runtime.v1.ContainerEventType
 */
export enum ContainerEventType {
  /**
   * Container created
   *
   * @generated from enum value: CONTAINER_CREATED_EVENT = 0;
   */
  CONTAINER_CREATED_EVENT = 0,

  /**
   * Container started
   *
   * @generated from enum value: CONTAINER_STARTED_EVENT = 1;
   */
  CONTAINER_STARTED_EVENT = 1,

  /**
   * Container stopped
   *
   * @generated from enum value: CONTAINER_STOPPED_EVENT = 2;
   */
  CONTAINER_STOPPED_EVENT = 2,

  /**
   * Container deleted
   *
   * @generated from enum value: CONTAINER_DELETED_EVENT = 3;
   */
  CONTAINER_DELETED_EVENT = 3,
}

/**
 * Describes the enum runtime.v1.ContainerEventType.
 */
export const ContainerEventTypeSchema: GenEnum<ContainerEventType> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 7);

/**
 * @generated from enum runtime.v1.MetricType
 */
export enum MetricType {
  /**
   * @generated from enum value: COUNTER = 0;
   */
  COUNTER = 0,

  /**
   * @generated from enum value: GAUGE = 1;
   */
  GAUGE = 1,
}

/**
 * Describes the enum runtime.v1.MetricType.
 */
export const MetricTypeSchema: GenEnum<MetricType> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 8);

/**
 * @generated from enum runtime.v1.CgroupDriver
 */
export enum CgroupDriver {
  /**
   * @generated from enum value: SYSTEMD = 0;
   */
  SYSTEMD = 0,

  /**
   * @generated from enum value: CGROUPFS = 1;
   */
  CGROUPFS = 1,
}

/**
 * Describes the enum runtime.v1.CgroupDriver.
 */
export const CgroupDriverSchema: GenEnum<CgroupDriver> = /*@__PURE__*/
  enumDesc(file_cri_api_pkg_apis_runtime_v1_api, 9);

/**
 * Runtime service defines the public APIs for remote container runtimes
 *
 * @generated from service runtime.v1.RuntimeService
 */
export const RuntimeService: GenService<{
  /**
   * Version returns the runtime name, runtime version, and runtime API version.
   *
   * @generated from rpc runtime.v1.RuntimeService.Version
   */
  version: {
    methodKind: "unary";
    input: typeof VersionRequestSchema;
    output: typeof VersionResponseSchema;
  },
  /**
   * RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure
   * the sandbox is in the ready state on success.
   *
   * @generated from rpc runtime.v1.RuntimeService.RunPodSandbox
   */
  runPodSandbox: {
    methodKind: "unary";
    input: typeof RunPodSandboxRequestSchema;
    output: typeof RunPodSandboxResponseSchema;
  },
  /**
   * StopPodSandbox stops any running process that is part of the sandbox and
   * reclaims network resources (e.g., IP addresses) allocated to the sandbox.
   * If there are any running containers in the sandbox, they must be forcibly
   * terminated.
   * This call is idempotent, and must not return an error if all relevant
   * resources have already been reclaimed. kubelet will call StopPodSandbox
   * at least once before calling RemovePodSandbox. It will also attempt to
   * reclaim resources eagerly, as soon as a sandbox is not needed. Hence,
   * multiple StopPodSandbox calls are expected.
   *
   * @generated from rpc runtime.v1.RuntimeService.StopPodSandbox
   */
  stopPodSandbox: {
    methodKind: "unary";
    input: typeof StopPodSandboxRequestSchema;
    output: typeof StopPodSandboxResponseSchema;
  },
  /**
   * RemovePodSandbox removes the sandbox. If there are any running containers
   * in the sandbox, they must be forcibly terminated and removed.
   * This call is idempotent, and must not return an error if the sandbox has
   * already been removed.
   *
   * @generated from rpc runtime.v1.RuntimeService.RemovePodSandbox
   */
  removePodSandbox: {
    methodKind: "unary";
    input: typeof RemovePodSandboxRequestSchema;
    output: typeof RemovePodSandboxResponseSchema;
  },
  /**
   * PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not
   * present, returns an error.
   *
   * @generated from rpc runtime.v1.RuntimeService.PodSandboxStatus
   */
  podSandboxStatus: {
    methodKind: "unary";
    input: typeof PodSandboxStatusRequestSchema;
    output: typeof PodSandboxStatusResponseSchema;
  },
  /**
   * ListPodSandbox returns a list of PodSandboxes.
   *
   * @generated from rpc runtime.v1.RuntimeService.ListPodSandbox
   */
  listPodSandbox: {
    methodKind: "unary";
    input: typeof ListPodSandboxRequestSchema;
    output: typeof ListPodSandboxResponseSchema;
  },
  /**
   * CreateContainer creates a new container in specified PodSandbox
   *
   * @generated from rpc runtime.v1.RuntimeService.CreateContainer
   */
  createContainer: {
    methodKind: "unary";
    input: typeof CreateContainerRequestSchema;
    output: typeof CreateContainerResponseSchema;
  },
  /**
   * StartContainer starts the container.
   *
   * @generated from rpc runtime.v1.RuntimeService.StartContainer
   */
  startContainer: {
    methodKind: "unary";
    input: typeof StartContainerRequestSchema;
    output: typeof StartContainerResponseSchema;
  },
  /**
   * StopContainer stops a running container with a grace period (i.e., timeout).
   * This call is idempotent, and must not return an error if the container has
   * already been stopped.
   * The runtime must forcibly kill the container after the grace period is
   * reached.
   *
   * @generated from rpc runtime.v1.RuntimeService.StopContainer
   */
  stopContainer: {
    methodKind: "unary";
    input: typeof StopContainerRequestSchema;
    output: typeof StopContainerResponseSchema;
  },
  /**
   * RemoveContainer removes the container. If the container is running, the
   * container must be forcibly removed.
   * This call is idempotent, and must not return an error if the container has
   * already been removed.
   *
   * @generated from rpc runtime.v1.RuntimeService.RemoveContainer
   */
  removeContainer: {
    methodKind: "unary";
    input: typeof RemoveContainerRequestSchema;
    output: typeof RemoveContainerResponseSchema;
  },
  /**
   * ListContainers lists all containers by filters.
   *
   * @generated from rpc runtime.v1.RuntimeService.ListContainers
   */
  listContainers: {
    methodKind: "unary";
    input: typeof ListContainersRequestSchema;
    output: typeof ListContainersResponseSchema;
  },
  /**
   * ContainerStatus returns status of the container. If the container is not
   * present, returns an error.
   *
   * @generated from rpc runtime.v1.RuntimeService.ContainerStatus
   */
  containerStatus: {
    methodKind: "unary";
    input: typeof ContainerStatusRequestSchema;
    output: typeof ContainerStatusResponseSchema;
  },
  /**
   * UpdateContainerResources updates ContainerConfig of the container synchronously.
   * If runtime fails to transactionally update the requested resources, an error is returned.
   *
   * @generated from rpc runtime.v1.RuntimeService.UpdateContainerResources
   */
  updateContainerResources: {
    methodKind: "unary";
    input: typeof UpdateContainerResourcesRequestSchema;
    output: typeof UpdateContainerResourcesResponseSchema;
  },
  /**
   * ReopenContainerLog asks runtime to reopen the stdout/stderr log file
   * for the container. This is often called after the log file has been
   * rotated. If the container is not running, container runtime can choose
   * to either create a new log file and return nil, or return an error.
   * Once it returns error, new container log file MUST NOT be created.
   *
   * @generated from rpc runtime.v1.RuntimeService.ReopenContainerLog
   */
  reopenContainerLog: {
    methodKind: "unary";
    input: typeof ReopenContainerLogRequestSchema;
    output: typeof ReopenContainerLogResponseSchema;
  },
  /**
   * ExecSync runs a command in a container synchronously.
   *
   * @generated from rpc runtime.v1.RuntimeService.ExecSync
   */
  execSync: {
    methodKind: "unary";
    input: typeof ExecSyncRequestSchema;
    output: typeof ExecSyncResponseSchema;
  },
  /**
   * Exec prepares a streaming endpoint to execute a command in the container.
   *
   * @generated from rpc runtime.v1.RuntimeService.Exec
   */
  exec: {
    methodKind: "unary";
    input: typeof ExecRequestSchema;
    output: typeof ExecResponseSchema;
  },
  /**
   * Attach prepares a streaming endpoint to attach to a running container.
   *
   * @generated from rpc runtime.v1.RuntimeService.Attach
   */
  attach: {
    methodKind: "unary";
    input: typeof AttachRequestSchema;
    output: typeof AttachResponseSchema;
  },
  /**
   * PortForward prepares a streaming endpoint to forward ports from a PodSandbox.
   *
   * @generated from rpc runtime.v1.RuntimeService.PortForward
   */
  portForward: {
    methodKind: "unary";
    input: typeof PortForwardRequestSchema;
    output: typeof PortForwardResponseSchema;
  },
  /**
   * ContainerStats returns stats of the container. If the container does not
   * exist, the call returns an error.
   *
   * @generated from rpc runtime.v1.RuntimeService.ContainerStats
   */
  containerStats: {
    methodKind: "unary";
    input: typeof ContainerStatsRequestSchema;
    output: typeof ContainerStatsResponseSchema;
  },
  /**
   * ListContainerStats returns stats of all running containers.
   *
   * @generated from rpc runtime.v1.RuntimeService.ListContainerStats
   */
  listContainerStats: {
    methodKind: "unary";
    input: typeof ListContainerStatsRequestSchema;
    output: typeof ListContainerStatsResponseSchema;
  },
  /**
   * PodSandboxStats returns stats of the pod sandbox. If the pod sandbox does not
   * exist, the call returns an error.
   *
   * @generated from rpc runtime.v1.RuntimeService.PodSandboxStats
   */
  podSandboxStats: {
    methodKind: "unary";
    input: typeof PodSandboxStatsRequestSchema;
    output: typeof PodSandboxStatsResponseSchema;
  },
  /**
   * ListPodSandboxStats returns stats of the pod sandboxes matching a filter.
   *
   * @generated from rpc runtime.v1.RuntimeService.ListPodSandboxStats
   */
  listPodSandboxStats: {
    methodKind: "unary";
    input: typeof ListPodSandboxStatsRequestSchema;
    output: typeof ListPodSandboxStatsResponseSchema;
  },
  /**
   * UpdateRuntimeConfig updates the runtime configuration based on the given request.
   *
   * @generated from rpc runtime.v1.RuntimeService.UpdateRuntimeConfig
   */
  updateRuntimeConfig: {
    methodKind: "unary";
    input: typeof UpdateRuntimeConfigRequestSchema;
    output: typeof UpdateRuntimeConfigResponseSchema;
  },
  /**
   * Status returns the status of the runtime.
   *
   * @generated from rpc runtime.v1.RuntimeService.Status
   */
  status: {
    methodKind: "unary";
    input: typeof StatusRequestSchema;
    output: typeof StatusResponseSchema;
  },
  /**
   * CheckpointContainer checkpoints a container
   *
   * @generated from rpc runtime.v1.RuntimeService.CheckpointContainer
   */
  checkpointContainer: {
    methodKind: "unary";
    input: typeof CheckpointContainerRequestSchema;
    output: typeof CheckpointContainerResponseSchema;
  },
  /**
   * GetContainerEvents gets container events from the CRI runtime
   *
   * @generated from rpc runtime.v1.RuntimeService.GetContainerEvents
   */
  getContainerEvents: {
    methodKind: "server_streaming";
    input: typeof GetEventsRequestSchema;
    output: typeof ContainerEventResponseSchema;
  },
  /**
   * ListMetricDescriptors gets the descriptors for the metrics that will be returned in ListPodSandboxMetrics.
   * This list should be static at startup: either the client and server restart together when
   * adding or removing metrics descriptors, or they should not change.
   * Put differently, if ListPodSandboxMetrics references a name that is not described in the initial
   * ListMetricDescriptors call, then the metric will not be broadcasted.
   *
   * @generated from rpc runtime.v1.RuntimeService.ListMetricDescriptors
   */
  listMetricDescriptors: {
    methodKind: "unary";
    input: typeof ListMetricDescriptorsRequestSchema;
    output: typeof ListMetricDescriptorsResponseSchema;
  },
  /**
   * ListPodSandboxMetrics gets pod sandbox metrics from CRI Runtime
   *
   * @generated from rpc runtime.v1.RuntimeService.ListPodSandboxMetrics
   */
  listPodSandboxMetrics: {
    methodKind: "unary";
    input: typeof ListPodSandboxMetricsRequestSchema;
    output: typeof ListPodSandboxMetricsResponseSchema;
  },
  /**
   * RuntimeConfig returns configuration information of the runtime.
   * A couple of notes:
   * - The RuntimeConfigRequest object is not to be confused with the contents of UpdateRuntimeConfigRequest.
   *   The former is for having runtime tell Kubelet what to do, the latter vice versa.
   * - It is the expectation of the Kubelet that these fields are static for the lifecycle of the Kubelet.
   *   The Kubelet will not re-request the RuntimeConfiguration after startup, and CRI implementations should
   *   avoid updating them without a full node reboot.
   *
   * @generated from rpc runtime.v1.RuntimeService.RuntimeConfig
   */
  runtimeConfig: {
    methodKind: "unary";
    input: typeof RuntimeConfigRequestSchema;
    output: typeof RuntimeConfigResponseSchema;
  },
  /**
   * UpdatePodSandboxResources synchronously updates the PodSandboxConfig with
   * the pod-level resource configuration. This method is called _after_ the
   * Kubelet reconfigures the pod-level cgroups.
   * This request is treated as best effort, and failure will not block the
   * Kubelet with proceeding with a resize.
   *
   * @generated from rpc runtime.v1.RuntimeService.UpdatePodSandboxResources
   */
  updatePodSandboxResources: {
    methodKind: "unary";
    input: typeof UpdatePodSandboxResourcesRequestSchema;
    output: typeof UpdatePodSandboxResourcesResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_cri_api_pkg_apis_runtime_v1_api, 0);

/**
 * ImageService defines the public APIs for managing images.
 *
 * @generated from service runtime.v1.ImageService
 */
export const ImageService: GenService<{
  /**
   * ListImages lists existing images.
   *
   * @generated from rpc runtime.v1.ImageService.ListImages
   */
  listImages: {
    methodKind: "unary";
    input: typeof ListImagesRequestSchema;
    output: typeof ListImagesResponseSchema;
  },
  /**
   * ImageStatus returns the status of the image. If the image is not
   * present, returns a response with ImageStatusResponse.Image set to
   * nil.
   *
   * @generated from rpc runtime.v1.ImageService.ImageStatus
   */
  imageStatus: {
    methodKind: "unary";
    input: typeof ImageStatusRequestSchema;
    output: typeof ImageStatusResponseSchema;
  },
  /**
   * PullImage pulls an image with authentication config.
   *
   * @generated from rpc runtime.v1.ImageService.PullImage
   */
  pullImage: {
    methodKind: "unary";
    input: typeof PullImageRequestSchema;
    output: typeof PullImageResponseSchema;
  },
  /**
   * RemoveImage removes the image.
   * This call is idempotent, and must not return an error if the image has
   * already been removed.
   *
   * @generated from rpc runtime.v1.ImageService.RemoveImage
   */
  removeImage: {
    methodKind: "unary";
    input: typeof RemoveImageRequestSchema;
    output: typeof RemoveImageResponseSchema;
  },
  /**
   * ImageFSInfo returns information of the filesystem that is used to store images.
   *
   * @generated from rpc runtime.v1.ImageService.ImageFsInfo
   */
  imageFsInfo: {
    methodKind: "unary";
    input: typeof ImageFsInfoRequestSchema;
    output: typeof ImageFsInfoResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_cri_api_pkg_apis_runtime_v1_api, 1);

